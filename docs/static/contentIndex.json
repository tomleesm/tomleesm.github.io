{"<好書推薦>為什麼他接的案子比我多":{"slug":"<好書推薦>為什麼他接的案子比我多","filePath":"<好書推薦>為什麼他接的案子比我多.md","title":"<好書推薦>為什麼他接的案子比我多","links":[],"tags":[],"content":"「如果你想學的是設計，請到設計學校就讀。如果你想學如何在設計界生存，請讀完這本書。」\n上面這句話是書打開後的第一句話，我覺得一點也不誇張，而且很多內容適合任何行業，不只是平面設計。作者文筆很好，通常先說一段故事，娓娓道來隱含的道理，結尾列出幾個準則和範例，讓人忍不住一直看下去。\n即使是老生常談，作者也能用生動的比喻和故事讓人心領神會，例如「55 善意的告知進度」：\n\n每一個小時，醫生都會派一名手術室的護士，到等候室跟家屬再次保證：「你的丈夫狀況很好，手術進度順利，沒有任何併發症」。這類親切的告知，讓家屬免於驚慌失措，在漫長的等候過程，不用一直提心吊膽，而是滿懷信心。\n\n主動告知客戶或主管目前的進度，可以減少他們對專案的擔憂，這在任何行業都重要。\n其實幾年前我就已經買下並看完這本書了，最近又重新翻過一遍，並且記筆記。這本書雖好，但是翻閱目錄時，無法從標題了解那個章節內容是什麼，例如「時限的魔術」，乍看之下還以為是加上時間限制可以提高工作效率，但實際上不是，所以閱讀這本書時最好寫筆記，記下標題以及該章節的摘要，像是這樣：\n\n\n時限的魔術\n\n提早讓主管知道，時間會來不及。沒人想突然收到壞消息。\n\n這本書好像絕版了，不過圖書館還是借得到的，也有二手書可以買1。\nFootnotes\n\n\nwww.taaze.tw/usedList.html ↩\n\n\n"},"Git-rebase-是什麼？":{"slug":"Git-rebase-是什麼？","filePath":"Git rebase 是什麼？.md","title":"Git rebase 是什麼？","links":[],"tags":[],"content":"首先新增一個目錄 test，並在目錄中新增文字檔 c，第一行新增數字 0，存檔後執行 git commit -a -m &#039;C0&#039;，接著第二行新增數字 1，存檔後執行 git commit -a -m &#039;C1&#039;，第三行新增數字 2，存檔後執行 git commit -a -m &#039;C2&#039;。\n以上，如果有分支 master 和 experiment 如下，C2 到 C3 的改變是檔案 c 第 4 行新增數字 3，C2 到 C4 的改變是檔案 c 第 1 行改成 5\n                C4 -- [master]\n               /\nC0 &lt;-- C1 &lt;-- C2\n               \\\n               C3 -- [experiment]\n\n切換分支到 experiment\ngit merge master：以 C3 和 C4 的共同祖先 C2 為基礎，比較 C2 到 C3 的改變 (第 4 行新增 3)，然後 C2 和 C4 的改變(第 1 行改成 5)，於是產生 C5，檔案 c 的內容和分支會是以下所示：\n5\n1\n2\n3\n\n                  C4 -- [master]\n                /    \\\nC0 &lt;-- C1 &lt;-- C2      C5 -- [experiment]\n                \\    /\n                  C3\n\ngit rebase master：\n\n回到兩個分支最近的共同祖先，根據當前分支（也就是要進行衍合的分支 experiment）後續的歷次提交物件（這裡只有一個 C3），生成一系列檔補丁，然後以基底分支（也就是主幹分支 master）最後一個提交物件（C4）為新的出發點，逐個應用之前準備好的補丁檔，最後會生成一個新的合併提交物件（C3’），從而改寫 experiment 的提交歷史，使它成為 master 分支的直接下游 （參考分支的衍合）\n\n以 C4 為基礎，把 C2 到 C3 的改變 (第 4 行新增 3) 改成移到 C4 上做(此時 C4 檔案內容是 5 1 2)，於是產生 C3’。重點是改寫歷史，C3 落單了，產生 C3’，分支 experiment 從指向 C3 改成指向 C3’。C3 會在 git 執行 gc 時清除掉。檔案 c 的內容和上面的 C5 是一樣的(5 1 2 3)。分支結果如下，為了方便和上面比較所以畫成這樣，一般會顯示成一直線。\n                 C4 -- [master]\n               /   \\\nC0 &lt;-- C1 &lt;-- C2   C3&#039; -- [experiment]\n\n                C3\n\nrebase 指令的一般形式是 git rebase [基礎分支] [被合併的分支]，所以上述的 rebase 等於指令 git rebase master experiment。如果省略被合併的分支，則使用當前分支。"},"Git-設定":{"slug":"Git-設定","filePath":"Git 設定.md","title":"Git 設定","links":[],"tags":[],"content":"使用 Neovim 編輯 commit 訊息，不套用 init.lua 設定，速度快\ngit config --global core.editor &#039;nvim -u NONE -N&#039;\n強制每個 Git Repository 都要設定使用者資訊\ngit config --global user.useConfigOnly true\ngit config --global --unset user.name\ngit config --global --unset user.email\ngit config --global --unset user.signingkey\n不允許 有 LF 與 CRLF 混合的檔案\ngit config --global core.safecrlf true\n方便的縮寫\n# git s 在 git status 只顯示檔名，不顯示分支名稱\ngit config --global alias.s &quot;status -bs&quot;\n# git br 等於 git branch\ngit config --global alias.br &quot;branch&quot;\n# git l 簡短顯示 git log 圖形：hash、新增或更新、commit 訊息\ngit config --global alias.l &quot;log --oneline --graph&quot;\n# git l 簡短顯示 git log 圖形：hash、多久前、誰、新增或更新、commit 訊息\ngit config --global alias.lt &#039;log --oneline --graph --pretty=format:&quot;%h [%ar] %an %s&quot;&#039;\ngit init 預設分支名稱爲 main，否則新版本的 Git 會跑出警告\ngit config --global init.defaultBranch main\n全域  .gitignore，不用每個專案都要設定 git ignore .DS_Store\ngit config --global core.excludesfile ~/.gitignore\n然後編輯 ~/.gitignore ，列出 .DS_Store 和 *.swp 等一般不放進 Git 的東西\ngit status 正常顯示中文檔名\ngit config --global core.quotepath false"},"GitHub-預設分支-master-改名為-main":{"slug":"GitHub-預設分支-master-改名為-main","filePath":"GitHub 預設分支 master 改名為 main.md","title":"GitHub 預設分支 master 改名為 main","links":[],"tags":[],"content":"今天把 GitHub 某個專案的預設分支從 master 改成 main，然後 GitHub 就顯示以下的說明：\nIf you have a local clone, you can update it by running the following commands.\ngit branch -m master main\ngit fetch origin\ngit branch -u origin/main main\ngit remote set-head origin -a\n好奇那是什麼意思，所以就查了一下，以後可能會用到\ngit branch -m master main\ngit branch -m：把 local 端的分支改名\ngit branch -m 舊的分支名稱 新的分支名稱\n可以只有 git branch -m 新的分支名稱，這表示把目前的分支改成新的分支名稱\ngit fetch origin\ngit fetch：同步遠端的 commit，但是不合併到 local 端\norigin 代表遠端節點\n# `git branch (--set-upstream-to=&lt;upstream&gt; | -u &lt;upstream&gt;) [&lt;branchname&gt;]`\ngit branch -u origin/main main\n參考 git-scm.com/docs/git-branch/#Documentation/git-branch.txt—ultupstreamgt\ngit branch -u 遠端分支 local分支：設定 local 分支要追蹤哪一個遠端分支。如果省略 local 分支，預設為目前的分支\n也可以改成 git branch --set-upstream-to=origin/main main\ngit remote set-head origin -a\n參考 git-scm.com/docs/git-remote#Documentation/git-remote.txt-emset-headem\n說真的，看不太懂。猜測會不會是查詢目前遠端(GitHub)的 HEAD 指向哪一個分支，然後自動設定 local 端的遠端 HEAD 使用相同的分支？"},"HTTP-通訊協議簡介":{"slug":"HTTP-通訊協議簡介","filePath":"HTTP 通訊協議簡介.md","title":"HTTP 通訊協議簡介","links":[],"tags":[],"content":"以下內容是我閱讀書籍「深入淺出 Servlets 與 JSP」後所做的筆記，用來複習 session 和 cookie 的基本觀念。\nHTTP 請求與回應\n使用者點選一個網站連結，連到 /products.php，則瀏覽器會產生一個 HTTP 請求類似這樣：\n\nGET /products.php：請給我一個檔案或資源，它是在 /products.php，參數是 id=123\nHTTP/1.1：這個 HTTP 請求的協議的版本是 1.1\nHost：伺服器主機所在的網址\nUser-Agent：產生 HTTP 請求的瀏覽器名稱\nAccept：告訴伺服器瀏覽器可以接受的資料是什麼類型\n\nGET /products.php HTTP/1.1\nHost: www.example.com\nUser-Agent: Mozilla/5.0\nAccept: text/html\nAccept-Language: en-us,zh-tw\nAccept-Encoding: gzip\nAccept-Charset: utf-8\nKeep-Alive: 300\nConnection: keep-alive\n瀏覽器把上述的 HTTP 請求傳送到伺服器，伺服器發現這個 HTTP 請求需要用 PHP 才能處理，所以丟給 PHP 程式。PHP 處理後產生 HTML，交給伺服器。伺服器把 HTML 處理後產生 HTTP 回應類似這樣：\n\n200 OK：回應的 HTTP 狀態碼和狀態碼的對應文字\nContent-Type：告訴瀏覽器要接收的資料是什麼類型\nServer：產生 HTTP 回應的伺服器軟體是 nginx 1.18.0 版\nHTML 放在 body 區塊，只顯示一部分\n\nHTTP/1.1 200 OK\nCache-Control: no-cache, private\nConnection: keep-alive\nContent-Encoding: gzip\nContent-Type: text/html; charset=UTF-8\nDate: Mon, 06 Jun 2022 07:28:34 GMT\nServer: nginx/1.18.0\nSet-Cookie: session=eyJpdiI6IkY5MTltbm1nSE1cL29ZbDE3b01OdXlBPT0iLCJ2YWx1ZSI6ImtYbEFN;expires=Mon, 06-Jun-2022 09:28:34 GMT; Max-Age=7200; path=/products.php httponly\nTransfer-Encoding: chunked\n&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n    &lt;head&gt;\n        &lt;meta charset=&quot;utf-8&quot;&gt;\n        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;\n伺服器把上述的 HTTP 回應傳送回瀏覽器，瀏覽器把 HTML 處理後呈現在螢幕上，讓使用者看到\nsession 與 cookie\n如果使用 session 和 cookie 儲存使用者的購物清單，會是這樣的：\n\n使用者點選一個連結，把產品加到購物車中\n伺服器產生一個 session 檔案，儲存購物清單，並給 session 一個編號 ABC123\n伺服器在 HTTP 回應的 header 加上 Set-Cookie: session_id=ABC123\n瀏覽器收到 HTTP 回應後，產生一個 cookie 檔案，儲存 session_id=ABC123\n瀏覽器讀取 cookie，產生新的 HTTP 請求，在 header 有 Cookie: session_id=ABC123\n伺服器收到 HTTP 請求後，依照 header Cookie: session_id=ABC123 就知道要找哪一個 session\n伺服器找到編號 ABC123 的 session，讀取購物清單\n\n如果想要的是使用者登入後，一直維持已登入狀態，則只要在第 2 點儲存購物清單改成儲存 login=true 之類的已登入標示，接著就是第 3 點之後那樣。\n當然也可以用 cookie 儲存購物清單：\n\n使用者點選一個連結，把產品 productA 和 productB 加到購物車中\n伺服器在 HTTP 回應的 header 加上 Set-Cookie: shopping_cart=productA,productB\n瀏覽器收到 HTTP 回應後，產生一個 cookie 檔案，儲存 shopping_cart=productA,productB\n瀏覽器讀取 cookie，產生新的 HTTP 請求，在 header 有 Cookie: shopping_cart=productA,productB\n伺服器收到 HTTP 請求後，依照 header  Cookie: shopping_cart=productA,productB 產生購物清單\n\n過期\ncookie 和 session 會設定一段時間後就過期被刪除，避免很久沒用的 cookie 和 session 佔用磁碟空間。重新產生 session 和 cookie 的過程如下：\n\n儲存著 session_id=ABC123 的 cookie 過期，瀏覽器刪除這個 cookie\n瀏覽器發出 HTTP 請求，header 沒有 Cookie: session_id=ABC123\n伺服器收到 HTTP 請求，因爲 header 沒有 Cookie: session_id=ABC123，不會尋找這個 session\n使用者做了一些事情，需要用 session 儲存資料\n伺服器產生新的 session，用 HTTP 回應傳送新的 session_id 給瀏覽器\nsession_id=ABC123 的 session 過了一段時間後過期，被伺服器刪除\n"},"Netrw-簡介":{"slug":"Netrw-簡介","filePath":"Netrw 簡介.md","title":"Netrw 簡介","links":[],"tags":[],"content":"Vim 內建檔案瀏覽器 Netrw，是像 VS Code 左側的檔案清單，所以其實不需要安裝其它外掛，例如 nvim-neo-tree/neo-tree.nvim、prichrd/netrw.nvim 或 nvim-tree/nvim-tree.lua 。不過需要一些設定才行。\n在終端機執行 vim 時，如果開啟的是目錄，則自動使用 Netrw 。或者在 Vim 中執行指令 :Explore 或縮寫 :E ，也能開啟 Netrw。請把 Netrw 視為 buffer，所以關閉 Netrw 的方法是指令 :bdelete 或縮寫 :bd。不過用 :ls 不會列出 Netrw\n如何產生類似 VS Code 預設的，左側 sidebar，開啟檔案後維持 sidebar 顯示？\n首先在 .vimrc 輸入以下設定\n\nlet g:netrw_liststyle = 3 顯示為樹狀結構\nlet g:netrw_banner = 0 不顯示上方的 banner\nlet g:netrw_winsize = 30 分割視窗的寬度為 30%\n\n然後執行指令 :Lexplore，會在左邊分割視窗開啟 Netrw，選擇檔案開啟後 Netrw 仍會顯示。再次輸入 Lexplore 會關閉 Netrw\n在 .vimrc 設定輸入 &lt;Leader&gt;f 會切換顯示 Netrw（&lt;Leader&gt; 鍵設定為 , 逗號）\nnnoremap &lt;LEADER&gt;f :Lexplore&lt;CR&gt;\n常用指令\n\nEnter：開啟目錄或檔案\n-：進入上一層目錄\nu：返回歷史記錄中的上一個目錄\n&lt;C-L&gt;：更新目錄清單\np：在下方水平分割視窗顯示預覽。曾經預覽過的檔案，關閉 vim 後會在下次預覽時直接打開檔案，而且是唯讀、沒有進到 buffer\n&lt;C-W&gt;z：關閉預覽視窗\ngh：切換隱藏檔案\n%：詢問新的檔案名稱，並新增和編輯它\nR：重新命名或移動檔案\nd：建立目錄\n"},"PHP-物件導向語法筆記":{"slug":"PHP-物件導向語法筆記","filePath":"PHP 物件導向語法筆記.md","title":"PHP 物件導向語法筆記","links":[],"tags":[],"content":"參考 PHP 官方文件 ，沒看過、記不起來，或覺得有必要的才在這裡寫筆記。\nProperties\nclass 中的變數，至少要有一個修飾詞  Visibility、 Static Keyword 或是 readonly (PHP 8.1.0 以上)。宣告時的初始值必須是常數(基本型別或 constant )，表示必須在編譯時期確定其值，而不是在 runtime 時。沒有 Visibility 的屬性，預設是 public，所以 static $var = 1 ，則此屬性預設是 public\nPHP 7.4.0 開始，可以有 Type declarations 的屬性，必須在存取前初始化，否則會丟出 Error ，不會自動給預設值 0, 0.0F, 或空字串。沒有  Type declarations 的屬性 ( 例如 public $var)，則會給預設值 null\nClass Constants\n一個類別建立一個 class constant，不是一個物件建立一個。\n&lt;?php\nclass A\n{\n  const C = &#039;C&#039;;\n  \n  public function getConstant() {\n    return self::C;\n  }\n}\nclass constant C 只有一個，歸屬於類別 A，即使是 new 三個物件 A，分給變數 $a1, $a2 和 $a3，也只有一個 class constant C，所以使用 $a1::C 存取，不是 $a1-&gt;C，在內部存取是用 self::C，不過用 $this-&gt;C 也可以，但是那樣的話用 $a1-&gt;getConstant() 會產生錯誤。總之，把 class constant 當做 static final 變數來使用\nAutoloading Classes\nnew 一個不屬於標準程式庫的類別，或是定義類別， 會自動執行 spl_autoload_register() 第一個參數的 callable，一般是一個函式。通常用來自動載入類別定義，省去一堆的 require_once()。目前只需要學會用 composer 就好，不用自己呼叫 spl_autoload_register() 。\nConstructor 和 Destructor\n如果子類別有定義建構式，必須在第一行用 parent::__construct() 先呼叫父類別的建構式。而且子類別不用遵守 Signature compatibility rules ，也就是說建構式的參數沒有限制數量，沒有限制要和父類別方法的參數一樣提供預設值等。\nPHP 沒有和 Java 一樣，可以對建構式 overloading，一個類別只有建構式，所以推薦使用 Static creation methods。經過測試 (在 PHP 7.4.28 中)，範例中可以改成用 new Product(1, &#039;milk&#039;)。\nScope Resolution Operator (::)\n兩個冒號可以有以下語法：\n\nself::$staticVar：同一個類別的靜態變數\nself::constant：同一個類別的常數\nparent::$staticVar：父類別靜態變數\nparent::constant：父類別常數\nparent::__construct()：父類別建構式\nparent::myFunction()：父類別的靜態和「一般」方法\n\n但是 parent::$var 不是存取父類別的一般變數，而是父類別靜態變數。而且沒有 parent-&gt;$var 這樣的語法\nObject Inheritance\n子類別必須和父類別相同，或比父類別更開放或更多。參考 Signature compatibility rules\n\n父類別方法 protected；子類別方法必須是 protected 或 public\n父類別方法有一個參數，而且參數沒有預設值；子類別方法必須有一個參數以上，而且參數可以有預設值\n父類別方法沒有 return  Type declarations，子類別方法可以有 return  Type declarations`\n如果 return  Type declarations 是類別，爲了遵守基本的多型機制(里式替換原則)，所以子類別可以比父類別的 return type 更緊縮，方法的參數型別則是子類別可以比父類別更開放。參考 Covariance and Contravariance\n\nTraits\n方法名稱衝突時\n&lt;?php\ntrait A {\n    public function smallTalk() {\n        echo &#039;a&#039;;\n    }\n    public function bigTalk() {\n        echo &#039;A&#039;;\n    }\n    public function otherTalk() {\n        echo &#039;+&#039;;\n    }\n}\ntrait B {\n    public function smallTalk() {\n        echo &#039;b&#039;;\n    }\n    public function bigTalk() {\n        echo &#039;B&#039;;\n    }\n    public function otherTalk() {\n        echo &#039;-&#039;;\n    }\n}\ntrait C {\n    public function smallTalk() {\n        echo &#039;c&#039;;\n    }\n    public function bigTalk() {\n        echo &#039;C&#039;;\n    }\n    public function otherTalk() {\n        echo &#039;*&#039;;\n    }\n}\nclass Talker\n{\n    // 三個 trait 方法名稱都一樣，在 use {} 中指定用哪個\n    use A, B, C {\n        // 使用 B 的 smallTalk() 而不是 A 或 C 的\n        // 注意是 B::smallTalk，沒有小括號！沒有小括號！沒有小括號！\n        B::smallTalk insteadof A, C;\n        A::bigTalk insteadof B, C;\n        C::otherTalk insteadof A, B;\n        // C 的 otherTalk 可以改名 talk\n        // 所以 $t-&gt;talk() 和 $t-&gt;otherTalk() 都可以\n        C::otherTalk as talk;\n    }\n}\n \n$t = new Talker();\n$t-&gt;smallTalk(); // b\n$t-&gt;bigTalk(); // A\n$t-&gt;otherTalk(); // *\n$t-&gt;talk(); // *\n?&gt;\ntrait 可以定義靜態屬性，如果類別使用這個 trait，則此靜態屬性是隨著物件生成的，不是隨著 trait，也就是說以下的 trait Counter，如果被類別 C1 和 C2 使用，則會有兩個靜態屬性 $c 分屬 C1 和 C2，不是只有一個\n&lt;?php\ntrait Counter {\n  private static $c = 0;\n  \n  public function inc() {\n    self::$c++;\n    echo self::$c . &quot;\\n&quot;;\n  }\n}\nOverloading\n一般程式語言的 overloading 是指 function 可以有不同的參數種類和數量，例如 Java String Constructors 有 15 個(Java 使用和類別相同名稱的 method 作爲建構式)， Java 程式依照參數數量(0 ~ 4 個)和參數型別決定要呼叫哪一個建構式。\n但是 PHP 的 overloading 指的是動態產生類別的屬性和方法。下表的屬性 name 在類別中沒有定義或不是設爲 public ，所以是在類別定義外面直接設定和存取的\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmagic function何時執行參數意義回傳值__set(string, $name, mix $value): void$object-&gt;name = 123$name：屬性的名稱(字串 name)，$value：屬性被設定的值(123)沒有回傳值__get(string $name): mix存取 $object-&gt;name$name：屬性的名稱(字串 name)在__get() 中回傳的值，決定 $object-&gt;name 屬性的值__isset(string $name): boolisset($object-&gt;name)$name：屬性的名稱(字串 name)在 __isset() 中回傳的值，決定 isset() 的值。回傳值如果不是 bool 型別，會自動轉型__unset(string $name): voidunset($object-&gt;name)$name：屬性的名稱(字串 name)沒有回傳值\n下表的方法 run 在類別中沒有定義或不是設爲 public，所以是在類別定義外面直接呼叫\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmagic function何時執行參數意義回傳值public __call(string $name, array $arguments): mixobject-&gt;run(&#039;arg 1&#039;, 123)$name：呼叫的方法名稱(字串 run)，$arguments：呼叫方法時所有的參數( [&#039;arg 1&#039;, 123] )呼叫方法的回傳值public __callStatic(string $name, array $arguments): mixMyClass::run(&#039;arg 2&#039;, 456)$name：呼叫的靜態方法名稱(字串 run)，$arguments：呼叫靜態方法時所有的參數( [&#039;arg 2&#039;, 456] )呼叫靜態方法的回傳值\nFinal\nfinal 只能用在類別和方法。顧名思義爲「最後」，表示不會改變。\n\n屬性不能設爲 final，而是使用 const 代表屬性是不能改變的常數\n方法設爲 final，則不能被子類別 override ，改變成另一種方法\n類別設爲 final，則不能被繼承，改變成另一種類別\n\nObject Cloning\n使用 clone $obj 或 clone($obj) 複製物件的所有屬性和值，包含 private 和 protected 屬性，如果有定義 __clone()，則會在複製屬性後執行它\nObject Serialization\nserialize() 會把物件轉成 byte-stream 字串，unserialize() 根據此字串還原成物件。所以可以把物件 Serialization 後存成檔案放到其他地方，之後再 Unserialization 還原成物件後繼續執行\n&lt;?php\n// classa.inc:\n  \n  class A {\n      public $one = 1;\n    \n      public function show_one() {\n          echo $this-&gt;one;\n      }\n  }\n  \n// page1.php:\n \n  include(&quot;classa.inc&quot;);\n  \n  $a = new A;\n  $s = serialize($a);\n  // store $s somewhere where page2.php can find it.\n  file_put_contents(&#039;store&#039;, $s);\n \n// page2.php:\n  \n  // this is needed for the unserialize to work properly.\n  include(&quot;classa.inc&quot;);\n \n  $s = file_get_contents(&#039;store&#039;);\n  $a = unserialize($s);\n \n  // now use the function show_one() of the $a object.  \n  $a-&gt;show_one();\n?&gt;\n執行 php page1.php 會在同一目錄新增檔案 store，內容是字串 O:1:&quot;A&quot;:1:{s:3:&quot;one&quot;;i:1;}，然後 php page2.php 會依據此字串還原成物件，繼續執行\n官方文件的讀者留言\n\nNote that static members of an object are not serialized.\n\n但是實測結果，新增一個 public static $two = 2 ，結果完全可以存取\n官方文件寫說如果在 Object Serialization 前沒有類別定義，PHP 會把它變成 __PHP_Incomplete_Class_Name 類別的物件，基本上沒什麼用。實測會產生 PHP Fatal error，無法繼續執行"},"PostgreSQL-筆記":{"slug":"PostgreSQL-筆記","filePath":"PostgreSQL 筆記.md","title":"PostgreSQL 筆記","links":[],"tags":[],"content":"之前都在用 MySQL，好奇隔壁棚的 PostgreSQL 有什麼不一樣，所以想玩玩看。講 PostgreSQL 的書相比 MySQL 很少，幸運的是最近發現一本「SQL 語法查詢入門」，使用的是 PostgreSQL，所以以下是這本書的筆記。\n資料庫、資料表和資料欄名稱如果要用引號，必須用雙引號，資料欄的值如果要用引號，必須用單引號。\n新增和管理資料庫\n在 Linux 執行以下指令，用 PostgreSQL 預設的管理員帳號執行 psql 管理程式\nsudo -u postgres psql\n新增使用者和資料庫，並設定權限\n-- 新增使用者，同時設定密碼\nCREATE USER 使用者名稱 WITH PASSWORD &#039;密碼&#039;;\n-- 新增使用者和擁有者\nCREATE DATABASE 資料庫名稱 OWNER 使用者名稱;\n-- 設定使用者對資料庫有完整權限\nGRANT ALL PRIVILEGES ON DATABASE 資料庫名稱 to 使用者名稱;\npsql\n# 測試使用者能否登入\npsql -U 使用者名稱 -d 資料庫名稱 -h 127.0.0.1\n# 使用指定的資料庫和使用者執行 test.sql 儲存的 SQL，然後離開 psql\npsql -U 使用者名稱 -d 資料庫名稱 -h 127.0.0.1 -f test.sql\n# 顯示 psql 所有指令\n\\?\n# 更改連線的資料庫、使用者\n\\c[onnect] 資料庫名稱 使用者名稱\n# 離開 psql\n\\q\nSELECT 子句執行順序\nSELECT 欄位清單\nFROM 資料表\nWHERE 條件式\nGROUP BY 條件式\nHAVING 條件式\nORDER BY 條件式\n\nFROM 產生資料集合\nWHERE 過濾 FROM 產生的集合\nGROUP BY 彙整 WHERE 過濾後的集合\nHAVING 過濾 GROUP BY 彙整的集合\nSELECT 轉換過濾與彙集過的集合（通常是透過彙整函式）\nORDER BY 排序 SELECT 轉換後的集合\n\n(上述順序和說明來自 Effective SQL 中文版 P. 122，有稍加修改)\n新增資料表和 View\n-- 最常見的方式\nCREATE TABLE 資料表名稱 (\n  id serial,\n  name varchar(255) NOT NULL DEFAULT &#039;&#039;,\n  資料表名稱 資料形態 選項\n);\n \n-- 用 SELECT 查詢結果新增資料表。AS 不能省略\n-- 注意：只有複製新增資料表時的資料\nCREATE TABLE 資料表 AS\n  SELECT 欄位1, 欄位2 FROM 資料表名稱;\n-- 主鍵、外鍵、檢查、NOT NULL、UNIQUE 和 serial 等約束條件不會複製到新的資料表\n-- 所以主鍵等約束條件需要新增資料表後再設定\nALTER TABLE 資料表 ADD COLUMN id serial, ADD PRIMARY KEY (id);\n \n-- 複製來源資料表的欄位名稱、資料型別和 NOT NULL，建立新的資料表\n-- LIKE 來源資料表要用括號包起來\n-- 注意：新的資料表只有複製 NOT NULL，沒有主鍵、外鍵、檢查、UNIQUE 和 serial 等約束條件\nCREATE TABLE 新的資料表 (LIKE 來源資料表);\n \n-- 新增 VIEW\nCREATE VIEW VIEW名稱 AS SELECT ...;\nDROP VIEW VIEW名稱;\n \n-- 修改資料表\nALTER TABLE 資料表名稱 ADD COLUMN 欄位名稱 資料形態;\nALTER TABLE 資料表名稱 DROP COLUMN 欄位名稱;\nALTER TABLE 資料表名稱 ALTER COLUMN 欄位名稱 SET DATA TYPE 資料形態;\nALTER TABLE 資料表 RENAME TO 新的資料表名稱;\n-- 把 SELECT 查詢結果存到新增的資料表，不會原查詢的索引\nCREATE TABLE 資料表名稱 AS SELECT 查詢;\n \n-- 刪除資料表\nDROP TABLE 資料表名稱;\n資料形態\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n語法說明字元char(n)長度固定爲 n 的字元，少於 n 則自動以空格填滿，別名 character(n)varchar(n)最大長度爲 n 的字元text長度不固定，適合大量的字元，PostgreSQL 最大爲 1GB整數smallint-32,768 到 +32,767integer-2,147,483,648 到 +2,147,483,647bigint-9,223,372,036,854,775,808 到 +9,223,372,036,854,775,807smallserial1 到 32,767serial1 到 2,147,483,647bigserial1 到 9,223,372,036,854,775,807小數numeric(precision, scale) 或 decimal(precision, scale)例如 numeric(3, 1) 或 decimal(4, 2) (fixed-point)real6 位數 precision (floating-point)double precision15 位數 precision (floating-point)日期和時間dateSeptember 21, 2018、9/21/2018 或 2018-09-21，從西元前 4,713 年到 5,874,897 年time (with timezone)15:37 +8 或 12:24:06 PST，從 0000:00:00 到 24:00:00timestamp (with timezone) 或 timestamptz2018-09-21 15:06:27 Asia/Taipei，從西元前 4,713 年到 294,276 年interval時間區隔，例如 1 hour, 2 day 或 3 weeks，範圍是正負 178,000,000 年\n字元\n3 種沒有明顯效能差異，不用爲了效能改用 char(n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n語法說明upper(字串)轉成大寫lower(字串)轉成小寫initcap(字串)每個單字第一個字母轉大寫，其餘字母轉小寫(PostgreSQL 獨有)char_length(字串)字元數，注意：一個字中文回傳 1length(字串)字元數，注意：一個字中文回傳 1 (PostgreSQL 獨有)position(’, ’ in ‘Tan, Bella’)回傳 ’, ’ 在 ‘Tan, Bella’ 中的第一次出現的起始位置 (4)，注意：不是從 0 開始\n整數\nserial 是 PostgreSQL 獨有的資料形態，通常用於主鍵\n小數\n\nprecision：小數點左右兩側最多一共有幾位數\nscale：小數點右邊的位數 (預設爲0，即設爲整數)，不足會自動補 0\nprecision 和 scale 都省略，則自動依值決定直到上限爲止\n上限是小數點前 131,072位數，小數點後 16,383 位數\n超過設定的 precision 或 scale，則用下一位數決定 4 捨 5 入\n注意：如果需要精確數學計算，要使用 numeric 或 decimal。real 和 double precision 是浮點數，數學計算是不準確的\n\n時區\ntimestamp 輸入時通常要有時區，例如 ‘2018-12-31 01:00 EST’，時區可用縮寫 EST、和 UTC 的時差 +8，或時區資料庫 Asia/Taipei\nSELECT * FROM pg_catalog.pg_timezone_names ORDER BY utc_offset; 查詢時區資料庫清單，欄位 is_dst 代表是否使用日光節約時間\n時間戳記欄位例如 &#039;2019-12-01 18:37:12 EST&#039;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n語法說明date_part(‘year’, cast(時間戳記欄位 AS timestamptz)) return 2019擷取型別 date, time 或 timestamptz 的資料值extract(‘year’ from cast(時間戳記欄位 AS timestamptz)) return 2019擷取型別 date, time 或 timestamptz 的資料值 (SQL 標準)make_date(2018, 2, 22)回傳 date 型別資料 2018-02-22make_time(18, 4, 30.3)回傳 time 型別資料 18:04:30.3，沒有時區make_timestamptz(2018, 2, 22, 18, 4, 30.3, ‘Asia/Tokyo’)回傳 timestamp with time zone 型別資料 2018-02-22 17:04:30.3+8，系統時區設定爲 Asia/Taipei，所以是 17 點\n約束條件\n主鍵\nCREATE TABLE 資料表 (\n  id serial,\n  CONSTRAINT 主鍵名稱 PRIMARY KEY (id)\n);\nCREATE TABLE 資料表 (\n  column_1 integer,\n  column_2 integer,\n  CONSTRAINT 主鍵名稱 PRIMARY KEY (column_1, column_2)\n);\nCREATE TABLE 資料表 ( id serial CONSTRAINT 主鍵名稱 PRIMARY KEY );\nCREATE TABLE 資料表 ( id serial PRIMARY KEY );\n \nALTER TABLE 資料表 ADD CONSTRAINT 主鍵名稱 PRIMARY KEY (column_1, column_2);\nALTER TABLE 資料表 DROP CONSTRAINT 主鍵名稱;\n外鍵\nCREATE TABLE 資料表 (\n  foreign_key_name serial\n    CONSTRAINT 外鍵名稱 FOREIGN KEY REFERENCES 資料表 (資料欄)\n    ON DELETE CASCADE -- 自動刪除外鍵參考的主鍵資料\n);\n檢查\nCREATE TABLE 資料表 (\n  user_role varchar(50),\n  salary integer,\n  -- CHECK () 括號內的語法和 WHERE 子句相同\n  CONSTRAINT 檢查條件名稱 CHECK ( user_role IN (&#039;admin&#039;, &#039;staff&#039;) ),\n  CONSTRAINT 檢查條件名稱 CHECK ( salary &gt; 0 )\n);\nUNIQUE\nPostgreSQL 認爲 NULL 和 NULL 是無法比較的，所以欄位是 UNIQUE 時，可以儲存多筆資料是 NULL\nCREATE TABLE 資料表 (\n  email varchar(255),\n  CONSTRAINT 名稱 UNIQUE (email)\n);\nNOT NULL\nCREATE TABLE 資料表 (\n  欄位名稱 varchar(20) NOT NULL\n);\nALTER TABLE 資料表 ALTER COLUMN 欄位名稱 SET NOT NULL;\nALTER TABLE 資料表 ALTER COLUMN 欄位名稱 DROP NOT NULL;\n新增修改刪除資料\n-- 指定新增的欄位，PostgreSQL 使用單引號包住字串值\nINSERT INTO 資料表 (欄位1, 欄位2) VALUES (123, &#039;text&#039;), (456, &#039;text&#039;);\n-- 依照資料表欄位順序新增資料\nINSERT INTO 資料表 VALUES (123, &#039;text&#039;);\n-- 把 SELECT 查詢的結果新增到資料表\nINSERT INTO 資料表 SELECT * FROM ...;\n-- 用 SELECT 查詢結果新增到指定欄位\nINSERT INTO 目標資料表 (欄位1, 欄位2)\n  SELECT 欄位A, 欄位B FROM 欄位資料表;\n  \nUPDATE 資料表\nSET 欄位名稱1 = 值1,\n    欄位名稱2 = 值2\nWHERE id = 1\n \nDELETE FROM 資料表 WHERE id = 1;\n-- 清空資料表\nTRUNCATE TABLE 資料表;\n交易\nSTART TRANSACTION;\nCOMMIT;\nROLLBACK;\n探索資料\n-- 顯示所有欄位\nSELECT * FROM 資料表;\n-- 顯示欄位 t1, t2\nSELECT t1, t2 FROM 資料表;\n-- 只顯示欄位 t1 不重複的值\nSELECT DISTINCT t1 FROM 資料表;\n-- 每個選區的候選人，只顯示不重複的欄位組合\nSELECT DISTINCT 選區, 候選人姓名 FROM 候選人名冊;\n-- DESC 遞減，ASC 遞增（預設）\nSELECT * FROM 資料表 ORDER BY t1 DESC, t2 ASC;\n-- SELECT 子句中的欄位，有套用彙整函式，則可以不用出現在 GROUP BY\n-- 如果欄位沒有套用彙整函式，則必須出現在 GROUP BY\n-- 此爲 ANSI SQL 標準的規定\nSELECT 欄位1, 欄位2, count(*) FROM 資料表 GROUP BY 欄位1, 欄位2\n-- 只顯示 1 筆資料\nSELECT * FROM 資料表 LMIT 1;\n-- 從索引值 0 的資料開始，只顯示 5 筆（注意，第 1 筆資料的索引值是 0，不是 1）\nSELECT * FROM 資料表 LMIT 0, 5;\n \n-- 顯示 server 設定\n-- lc_collate：locale for collation 會影響排序順序\nSHOW ALL;\n-- 顯示系統設定的時區\nSHOW timezone;\n字元表對映著數字，排序依據此數字排序。例如 Unicode 字元表 A 對應到 65，a 對應到 97，所以遞增時 A 排在 a 前面。\nJOIN\n-- CROSS JOIN：將兩個資料表中所有可能的排列組合顯示出來。\n-- 如果表格 A 和 B 各有 4 和 5 筆資料，則所有可能的排列組合是 4 x 5 = 20 種，所以聯結顯示出來的結果是一個 20 列的表格\nSELECT * FROM 資料表1 CROSS JOIN 資料表2;\n-- 更常見的是這種語法\nSELECT * FROM 資料表1, 資料表2;\n \n-- INNER JOIN：透過條件過濾不需要的資料的 CROSS JOIN\n-- Tom 在2022-04-30 訂購的商品名稱、價格和產品分類\nSELECT p.&quot;name&quot; AS product, p.price, c.&quot;name&quot; AS category\nFROM users AS u\nINNER JOIN orders AS o ON u.id = o.user_id\nINNER JOIN order_details AS od ON o.id = od.order_id\nINNER JOIN products AS p ON p.id = od.product_id\nINNER JOIN product_categories AS c ON p.category_id = c.id\nWHERE u.&quot;name&quot; = &#039;Tom&#039; AND o.order_date = &#039;2022-04-30&#039;\n \n-- LEFT OUTER JOIN：以左邊的資料表爲主的 INNER JOIN，如果右邊資料表找不到值，則右邊欄位顯示爲 NULL\n-- RIGHT OUTER JOIN：以右邊的資料表爲主\n-- 常用來做「差集」，找出沒有什麼\nSELECT R.&quot;name&quot;\nFROM 左邊的資料表 AS L\nLEFT OUTER JOIN 右邊的資料表 AS R\nON L.id = R.id\nWHERE R.id IS NULL;\n \n-- FULL OUTER JOIN：LEFT 加上 RIGHT OUTER JOIN，基本上沒什麼用\nSELECT R.&quot;name&quot;\nFROM 左邊的資料表 AS L\nFULL OUTER JOIN 右邊的資料表 AS R\nON L.id = R.id\n \n-- NATURAL JOIN：自動尋找兩個表之間，名稱相同的欄位，進行 INNER JOIN，ON 條件為「等於」\nSELECT * FROM 資料表1 NATURAL JOIN 資料表2;\nUNION\n兩個資料表的連結(OR)。UNION 會去除重複的資料，UNION ALL 則保留重複的資料。應用參考 Effective SQL 做法 03 和 21，以及 P. 90\nSELECT 欄位1, 欄位2 FROM 資料表1\nUNION\nSELECT 欄位1, 欄位2 FROM 資料表2\n子查詢\n非關聯子查詢\n先執行括號內的查詢，其結果傳給外層繼續執行。非關聯性子查詢完全獨立執行，和外層查詢沒有關聯\nSELECT * FROM 資料表 WHERE id IN\n  (SELECT order_id FROM orders WHERE ...);\n關聯性子查詢\n先執行外層查詢，並傳回結果給內層子查詢以便執行。所以子查詢依賴外層查詢的結果，和外層查詢有關聯\n範例：計算 my_contacts 每個人有幾項興趣，並且回傳具有三項興趣的人，顯示姓名\nmy_contacts\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncontact_idfirst_namelast_name1JillianAnderson2LeoKenton3DarrinMcGavin\ncontact_interest\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncontact_idint_id121314213133\nSELECT mc.first_name, mc.last_name\nFROM my_contacts AS mc\nWHERE\n3 = (\n  SELECT COUNT(*) FROM contact_interest\n  WHERE contact_id = mc.contact_id\n);\n\n首先執行外層查詢：產生表格 my_contacts 的所有 SELECT 結果，包括 contact_id 和別名 mc\n1 的結果傳給內層子查詢，(第 6 行) mc.contact_id 一次使用傳來的一列資料，例如這次是 1 ，下次是 2，然後是 3\n所以依次執行子查詢 SELECT COUNT(*) FROM contact_interest WHERE contact_id = 1 (下次就是 2，然後 3)，回傳 contact_id = 1 的這個人有幾項興趣，在這個例子中是 3 項（PS. 聯絡人和興趣是多對多關係）\n第 4 行的 3 = (子查詢)：數字 3 在等號的左邊，表示「比較等號兩邊的數值是否相等」。子查詢的結果依序是 3, 1, 2 (項興趣)，所以只有第一個結果是 3 = (3)，回傳 TRUE 等號兩邊數值相同\n顯示等號兩邊數值相同的聯絡人姓名(第 1 行)，所以顯示 Jillian Anderson\n\n過濾條件\n-- a &lt;= x &lt;= b。a 一定要大於或等於 b，所以如果 BETWEEN 5 AND 3，會回傳空值\nWHERE x BETWEEN a AND b\nWHERE tags IN (&#039;A&#039;, &#039;B&#039;, &#039;C&#039;)\n-- LIKE 區分大小寫\n-- ILIKE 不區分大小寫(PostgreSQL 獨有 ILIKE 語法)\n-- % 一或多個字元，%abc 表示結尾是 abc，開頭是一或多個字元的字串\nWHERE 欄位 LIKE &#039;%abc&#039;\n-- _ 單獨一個字元， _abc 表示結尾是 abc，開頭是一個字元的字串\nWHERE 欄位 LIKE &#039;_abc&#039;\nEXISTS\n尋找「沒有」個人興趣的聯絡人姓名和電子郵件\nmy_contacts\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncontact_idfirst_namelast_name1JillianAnderson2LeoKenton3DarrinMcGavin4JoeFranklin\ncontact_interest\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncontact_idint_id12131421313353\nSELECT mc.first_name, mc.last_name, mc.email\nFROM my_contacts AS mc\nWHERE NOT EXISTS (\n  SELECT * FROM contact_interest AS ci\n  WHERE mc.contact_id = ci.contact_id\n);\n\n首先執行外層查詢：產生表格 my_contacts 的所有 SELECT 結果，包括 contact_id 和別名 mc\n1 的結果傳給內層子查詢，(第 5 行) mc.contact_id 一次使用傳來的一列資料，例如這次是 1 ，下次是 2，然後是 3\n所以依次執行子查詢 SELECT * FROM contact_interest AS ci WHERE 1 = ci.contact_id (下次就是 2，然後 3)，表示尋找 contact_interest 的 contact_id 是否也有 1，也就是這個人是否有個人興趣\n1 = ci.contact_id：不論數字 1 是在左還是右，都是「比較等號兩邊的數值是否相等」，所以 RDBMS 會去尋找所有的 ci.contact_id ( = 1, 2, 3, 5)，看看是否可能會相等，是的話回傳 TRUE，否則回傳 FALSE。mc.contact_id = 1，WHERE 條件得到 1 = 1，所以子查詢結果是 contact_id = 1 的 contact_interest 所有欄位資料\n但是 NOT EXISTS 要的是「不存在」的，「子查詢結果是有資料的」代表 TRUE，NOT EXISTS (TRUE) 結果是 FALSE。直到 mc.contact_id = 4，而 ci.contact_id = 1, 2, 3, 5，沒有 4，所以「不存在」4 = 4，子查詢結果回傳 FALSE，NOT EXISTS (FALSE)，回傳 TRUE\n所有 NOT EXISTS () 回傳 TRUE 的，表示這些人沒有個人興趣，則顯示他們的姓名和電子郵件\n\nEXISTS () 和 NOT EXISTS () 功用相反，它要的是「有存在」\n雖然 NOT EXISTS 搭配子查詢不好懂但很好用，通常用來尋找「沒有」的資料，例如哪些人沒有保險紀錄、哪些貓狗沒有打過疫苗，這樣就不用程式語言的   if(empty($sqlResult)) { // 顯示他們的資料 }\n除了 SELECT，子查詢也可以用在 INSERT、UPDATE 和 DELETE\n數學計算\nSELECT 2 + 2; -- 4 加\nSELECT 9 - 1; -- 8 減\nSELECT 3 * 4; -- 12 乘\nSELECT 11 / 6; -- 1 除\nSELECT 11 % 6; -- 5 取餘數\nSELECT 11.0 / 6; -- 1.83333 小數除\n-- 把整數 11 轉成 numeric 再除以 6\n-- 如果 11 來自整數欄位，無法手動改成 11.0，就要用 CAST() 轉型\nSELECT CASE(11 AS numeric(3, 1)) / 6;\nSELECT 3 ^ 4; -- 次方，3 的 4 次方等於 81\nSELECT |/ 10; -- 平方根\nSELECT sqrt(10); -- 平方根\nSELECT ||/ 10; -- 立方根\nSELECT 4!; -- 階乘，4! = 4 x 3 x 2 x 1 = 24\n-- 優先順序：指數和根 --&gt; 乘除餘數 --&gt; 加減\n \n-- 彙總函式\nSELECT sum(欄位) FROM 資料表; -- 加總\nSELECT avg(欄位) FROM 資料表; -- 平均\n-- 4 捨 5 入到小數點第幾位，scale：小數點右邊的位數 (預設爲0，即取到整數)\nSELECT round(欄位, scale) FROM 資料表;\n-- 百分位數，取平均數。例如 1, 2, 3, 4, 5, 6 中會自動取平均 3.5\nSELECT percentile_cont(0.5) WITHIN GROUP (ORDER BY 欄位) FROM 資料表;\n-- 百分位數，取前 50% 的最後一個數。例如 1, 2, 3, 4, 5, 6 中會自動取前 50% 的最後一個數 3\nSELECT percentile_disc(0.5) WITHIN GROUP (ORDER BY 欄位) FROM 資料表;\n-- unnest() 把陣列多筆資料，array[]：建立一個陣列\nSELECT unnest(array[&#039;25%&#039;, &#039;50%&#039;, &#039;75%&#039;]) AS &quot;百分比&quot;;\n-- percentile_test 只有一個資料欄 numbers，內含6筆資料 1, 2, 3, 4, 5, 6\n-- percentile_cont() 和 percentile_disc() 參數可以給它陣列，它回傳的也是陣列，\n-- 所以用 unnest() 轉成多筆資料\nSELECT unnest(array[&#039;25%&#039;, &#039;50%&#039;, &#039;75%&#039;]) AS &quot;百分比&quot;,\n       unnest(\n         percentile_cont(array[.25, .50, .75])\n           WITHIN GROUP (ORDER BY numbers)\n       ) AS &quot;百分位數(連續)&quot;,\n       unnest(\n         percentile_disc(array[.25, .50, .75])\n           WITHIN GROUP (ORDER BY numbers)\n       ) AS &quot;百分位數(離散)&quot;\nFROM percentile_test;\n \n-- 依照欄位 price 排名\n-- rank(): 排名，平手時留白，dense_rank(): 排名，平手時不留白(名次不會跳下一位)\nSELECT name, price,\n       rank() OVER (ORDER BY price DESC)\n         AS &quot;依照欄位 price 的總排名&quot;,\n       dense_rank() OVER (ORDER BY price DESC)\n         AS &quot;依照欄位 price 的總排名(不留白)&quot;,\n       rank() OVER (PARTION BY category ORDER BY price DESC)\n         AS &quot;依照欄位 category 分組後，欄位 price 在分組內的排名&quot;,\n       dense_rank() OVER (PARTION BY category ORDER BY price DESC)\n         AS &quot;依照欄位 category 分組後，欄位 price 在分組內的排名(不留白)&quot;,\nFROM products;\nETL 工具 COPY\nPostgreSQL 可以用 COPY 查詢，從 CSV 等文字檔匯入到資料庫，或匯出成文字檔。缺點是匯入或匯出的檔案必須和 PostgreSQL 在同一台機器上，但是用 \\copy 就沒有這樣的限制\n-- 匯入 CSV 檔到資料庫，資料表必須自行新增\n-- (欄位1, 欄位2)：可以指定匯入的欄位名稱，省略的話則依照資料欄順序\nCOPY 資料表 (欄位1, 欄位2)\n-- csv 檔位址，必須用絕對位址\nFROM &#039;C:\\your_dir\\your_file.csv&#039;\nWITH (FORMAT CSV, -- 指定格式是 CSV，另一常見格式是 TEXT\n\t  HEADER, -- 第一列是標題，不匯入\n\t  DELIMITER &#039;,&#039;, -- 用逗號分隔欄位，CSV 檔預設\n\t  QUOTE &#039;文字限定符&#039; -- 如有欄位值包含逗號，需用文字限定符包起來，CSV 檔預設是雙引號\n\t  );\n \n-- 匯出資料到 CSV 檔，選項同匯入\nCOPY 資料表 (欄位1, 欄位2)\nTO &#039;C:\\your_dir\\your_file.csv&#039;\nWITH (FORMAT CSV,\n\t  HEADER,\n\t  DELIMITER &#039;,&#039;,\n\t  QUOTE &#039;文字限定符&#039;\n\t  );\n \n-- 可以把 SELECT 查詢結果匯出到 CSV 檔\nCOPY (SELECT * FROM 資料表)\nTO &#039;C:\\your_dir\\your_file.csv&#039;\nWITH ...\n \n-- 基本上和上面的 COPY 查詢一樣，只是 COPY 改成 \\copy\n\\copy 資料表 (欄位1, 欄位2) FROM &#039;C:\\your_dir\\your_file.csv&#039; WITH (...);\n\\copy 資料表 (欄位1, 欄位2) TO &#039;C:\\your_dir\\your_file.csv&#039; WITH (...);\n\\copy (SELECT * FROM 資料表)\nTO &#039;C:\\your_dir\\your_file.csv&#039;\nWITH ...\n備份與還原\n# 備份到 SQL 文字檔\npg_dump -U 使用者名稱 -d 資料庫名稱 -h 127.0.0.1 --blobs &gt; 備份.sql\n# 用 SQL 文字檔還原資料庫\npsql -U 使用者名稱 -d 資料庫名稱 -h 127.0.0.1 -f 備份.sql\n# 備份到壓縮檔\npg_dump -U 使用者名稱 -d 資料庫名稱 -h 127.0.0.1 --blobs -Ft &gt; 備份.tar.gz\n# 用壓縮檔還原資料庫\npg_restore -U 使用者名稱 -d 資料庫名稱 -h 127.0.0.1 備份.tar.gz\n判斷查詢效能\n-- 顯示 PostreSQL 查詢計畫：如何掃描資料表、是否用到索引等\nEXPLAIN SELECT ...;\n-- 除了顯示 PostreSQL 查詢計畫，還會執行查詢，顯示實際執行時間\nEXPLAIN ANALYZE SELECT ...;\n索引\nCREATE INDEX 索引名稱 ON 資料表名稱 (欄位名稱);\n-- 排除索引 NULL，增加搜尋速度 (PostgreSQL 才能在新增索引時用 WHERE 子句)\nCREATE INDEX 索引名稱 ON 資料表名稱 (欄位名稱) WHERE 欄位名稱 IS NOT NULL;"},"RESTful-API-簡介":{"slug":"RESTful-API-簡介","filePath":"RESTful API 簡介.md","title":"RESTful API 簡介","links":[],"tags":[],"content":"參考 Build APIs You Won’t Hate\n規劃\n先思考名詞，再來是如何操作名詞\nPosts 文章 (名詞)\n\nCreate 新增\nRead 讀取\nUpdate 修改\nDelete 刪除\nList 列出全部清單\n\n請求\nRESTful API 使用 HTTP 動詞和網址配成一對，決定 API 路由規則，例如 GET /posts 回傳所有文章，但是 POST /posts 是新增一篇文章。哪個 HTTP 動詞搭配怎樣的網址有約定俗成的慣例如下：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHTTP 動詞網址說明冪等POST/posts新增文章XGET/posts/create顯示新增文章頁面OGET/posts/{post}回傳指定的文章OPUT/PATCH/posts/{post}修改指定的文章不一定GET/posts/{post}/edit顯示修改文章頁面ODELETE/posts/{post}刪除指定的文章OGET/posts回傳全部文章O\n{post} 代表文章 id（例如 123）\n一般來說保持 HTTP 動詞搭配網址的形式，才符合 RESTful\n\n路由中的 URL 都是名詞\n動詞用 HTTP 動詞表示\n\n但是非 CRUD 操作就不一定會依照上面表格的慣例使用 HTTP 動詞表示操作動作，有三種做法：\n\n用 JSON 放在 HTTP request body，例如 { &quot;lock&quot;: true }\n放在網址中當做資源向後連接，例如 /posts/123/lock\n放在網址，但是使用傳統的格式，最常見的是搜尋，例如 /search?q=abc&amp;location=home\n\n網址 posts 被稱爲資源，資源可以向後連接，代表更進一步的意義，例如：\n\nGET /posts/123/comments 回傳 id 爲 123 的文章的所有留言\nPUT /posts/123/comments/456 修改 id 爲 123 的文章中，id 爲 456 的留言\n\n冪等 idempotence\n冪：音同「蜜」。冪等：無論執行多少次，結果都一樣\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHTTP 動詞冪等修改資料說明GETOX查詢 meta 和 body 資料HEADOX查詢 meta 資料PUTOO修改所有欄位DELETEOO刪除。不論刪除多少次，結果都是沒有資料POSTXO新增。即使欄位資料一樣，每次新增的主鍵也不一樣，所以不是冪等PATCHXO修改部分欄位\nPATCH 不用一定要冪等，當然有冪等也可以，舉例：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n之前操作之後冪等{name: &quot;Tom&quot;, age: 32}PATCH age 改成 33{name: &quot;Tom&quot;, age: 33}O{name: &quot;Tom&quot;, age: 32}PATCH age 增加 1{name: &quot;Tom&quot;, age: 33}X\n回應\n回傳的結果通常是 JSON，所以 Content-Type 請指定爲 application/json，推薦回應的 JSON 格式如下，不管是一筆或多筆資料，都是一致的：\n這是一筆資料\n{\n  &quot;data&quot;: {\n    &quot;name&quot;: &quot;Tom&quot;,\n    &quot;email&quot;: &quot;tom@email.com&quot;\n  }\n}\n這是多筆資料，即使巢狀結構也能保持一致\n{\n  &quot;data&quot;: [\n    {\n      &quot;name&quot;: &quot;Tom&quot;,\n      &quot;email&quot;: &quot;tom@email.com&quot;\n    },\n    {\n      &quot;name&quot;: &quot;John&quot;,\n      &quot;email&quot;: &quot;john@email.com&quot;\n    },\n    {\n      &quot;name&quot;: &quot;Alice&quot;,\n      &quot;email&quot;: &quot;alice@email.com&quot;,\n      &quot;posts&quot;: {\n        &quot;data&quot;: [\n          {\n            &quot;title&quot;: &quot;title of post 1&quot;,\n            &quot;content&quot;: &quot;content of post 1&quot;\n          },\n          {\n            &quot;title&quot;: &quot;title of post 2&quot;,\n            &quot;content&quot;: &quot;content of post 2&quot;\n          }\n        ]\n      }\n    }\n  ],\n  &quot;pagination&quot;: {\n    &quot;total&quot;: 1000,\n    &quot;count&quot;: 10,\n    &quot;perPage&quot;: 10,\n    &quot;currentPage&quot;: 2,\n    &quot;totalPages&quot;: 100,\n    &quot;nextUrl&quot;: &quot;/posts?page=2&amp;per_page=10&quot;\n  }\n}\n以上只列出 3 筆資料"},"Windows-10-推薦軟體":{"slug":"Windows-10-推薦軟體","filePath":"Windows 10 推薦軟體.md","title":"Windows 10 推薦軟體","links":[],"tags":[],"content":"影片播放\nLinux 我用 mpv 播放影片，Windows 10 也能用 mpv ，用 scoop 安裝1，不過需要用指令 mpv，所以推薦用 mpv-hero，啟動速度快，還多了許多功能，例如右鍵選單、實用的圖形界面、和 YouTube 一樣的影片預覽、最近播放清單\n只是安裝有點麻煩：\n\n在 Releases 下載壓縮檔\n在 home 目錄新增 apps 資料夾，解壓縮到裡面。因為安裝後會固定尋找當初安裝的路徑，所以放在 apps\n執行資料夾 installer 的 mpv-install.bat ，需要用系統管理員權限，所以右鍵 Run as administrator。如果沒有，可能是設定成預設用 Notepad++ 打開\n執行完 mpv-install.bat，依照指示按鍵會出現 Default apps 設定，或是手動打開 Windows 的設定 &gt; Apps &gt; Default apps ，設定用 mpv 做為預設的音樂和影片播放器\n\nFootnotes\n\n\nmpv.io/installation/ ↩\n\n\n"},"Windows-Terminal-設定多個字體":{"slug":"Windows-Terminal-設定多個字體","filePath":"Windows Terminal 設定多個字體.md","title":"Windows Terminal 設定多個字體","links":[],"tags":[],"content":"點選 Windows Terminal 分頁右邊的向下箭頭，點選後顯示「設定」，再點選左邊清單設定檔 &gt; 預設值 &gt; 其他設定 &gt; 外觀 &gt; 字體，在右邊的輸入框直接輸入字體名稱，名稱最好參考 Windows 設定 &gt; 字型，並用逗號隔開，而不是從選單選擇，如下所示。\nMonaspace Neon, Symbols Nerd Font , Noto Sans TC\n以上設定使用三種字體：Github Monaspace Neon、Symbols Nerd Font 和 Noto Sans TC"},"index":{"slug":"index","filePath":"index.md","title":"wiki","links":["Git-rebase-是什麼？","HTTP-通訊協議簡介","RESTful-API-簡介","為什麼要有例外處理？","解-UVa-線上解題系統的題目","資料庫正規化，以魔法學校課程為例","GitHub-預設分支-master-改名為-main","Git-設定","memos-安裝到-Debian-9","Netrw-簡介","PHP-物件導向語法筆記","PostgreSQL-筆記","Windows-10-推薦軟體","Windows-Terminal-設定多個字體","使用-API-Blueprint-寫文件","使用-Docker-Compose-安裝-Laravel-和-Vue.js-環境","使用-docker-執行-node.js","在-Dedian-11-安裝-LEMP-開發環境跑-Laravel-10","在-Dedian-12-安裝-LEMP-開發環境跑-Laravel-10","常用-Vim-指令清單","從-Vim-到-Neovim","用-Vim-把事情分得很細","解決-VTE-為基礎的終端機程式游標問題","這週看了什麼書","<好書推薦>為什麼他接的案子比我多","我為什麼想不開用-Vim-寫程式？","怎麽學-Vim-？","時間管理方法","有興趣但是還沒研究的東西","用-Linux-Mint-做為工作環境"],"tags":[],"content":"程式設計觀念\n\nGit rebase 是什麼？\nHTTP 通訊協議簡介\nRESTful API 簡介\n為什麼要有例外處理？\n解 UVa 線上解題系統的題目\n資料庫正規化，以魔法學校課程為例\n\n程式安裝、設定和語法\n\nGitHub 預設分支 master 改名為 main\nGit 設定\nmemos 安裝到 Debian 9\nNetrw 簡介\nPHP 物件導向語法筆記\nPostgreSQL 筆記\nWindows 10 推薦軟體\nWindows Terminal 設定多個字體\n使用 API Blueprint 寫文件\n使用 Docker Compose 安裝 Laravel 和 Vue.js 環境\n使用 docker 執行 node.js\n在 Dedian 11 安裝 LEMP 開發環境跑 Laravel 10\n在 Dedian 12 安裝 LEMP 開發環境跑 Laravel 10\n常用 Vim 指令清單\n從 Vim 到 Neovim\n用 Vim 把事情分得很細\n解決 VTE 為基礎的終端機程式游標問題\n\n其它\n\n這週看了什麼書\n&lt;好書推薦&gt;為什麼他接的案子比我多\n我為什麼想不開用 Vim 寫程式？\n怎麽學 Vim ？\n時間管理方法\n有興趣但是還沒研究的東西\n用 Linux Mint 做為工作環境\n"},"memos-安裝到-Debian-9":{"slug":"memos-安裝到-Debian-9","filePath":"memos 安裝到 Debian 9.md","title":"memos 安裝到 Debian 9","links":[],"tags":[],"content":"memos 官網文件只有寫怎麼用 Docker 安裝，但是產生的 SQlite 檔案是 root 權限，所以試著編譯原始碼產生執行檔\n# 安裝 Node.js\nsudo apt install curl build-essential\ncurl -sL deb.nodesource.com/setup_20.x | sudo bash -\nsudo apt install nodejs\nnode -v\nnpm -v\n \ncd /tmp\ngit clone github.com/usememos/memos.git\ncd memos/web\nsudo corepack enable\n輸入 Y 和 Enter 安裝 pnpm 和 package.json 所列套件\npnpm i --frozen-lockfile\n編輯 package.json，加上 NODE_OPTIONS=&#039;–max_old_space_size=1024&#039;\n設定使用 1 GB，否則 pnpm build 會丟出 GC exception。假設主機是 2GB VM\n&quot;scripts&quot;: {\n  &quot;build&quot;: &quot;NODE_OPTIONS=&#039;–max_old_space_size=1024&#039; tsc &amp;&amp; vite build&quot;\n}\n然後執行 pnpm build\n參考\n\nMemos Dockerfile 設定\nnodejs.org/api/cli.html#cli_max_old_space_size_size_in_megabytes\n\n複製 docker 容器內的 memos 執行檔到 host 端執行\n新增檔案 docker-compose.yaml\nservices:\n  memos:\n    container_name: memos\n    image: ghcr.io/usememos/memos:0.21.0\n    ports:\n      - 127.0.0.1:5230:5230\n    restart: always\n    volumes:\n      - ./data/:/var/opt/memos\n執行以下指令\ndocker compose up -d\ndocker compose exec memos /bin/sh\ncp -r dist/ /var/opt/memos\ncp memos /var/opt/memos\nexit\ndocker compose down -v\ndocker image rm ghcr.io/usememos/memos:0.21.0\n \n# 假設目前使用者是 tom\nsudo chown tom:tom -R *\n執行 ./memos，用瀏覽器瀏覽 http://127.0.0.1:8081 ，應該能看到 Memos 執行\n開機執行 memos\n建立一個新的 Systemd 服務單位設定檔，儲存於 /etc/systemd/system/memos.service（需要 sudo）\n[Unit]\nDescription=Memos\n\n[Service]\nType=simple\nWorkingDirectory=/home/tom/Dropbox/apps/memos/\nExecStart=/home/tom/Dropbox/apps/memos/memos\nRestart=always\nUser=tom\nGroup=tom\n\n[Install]\nWantedBy=multi-user.target\n\n執行以下指令\n# 資料儲存在我的 Dropbox\nchmod +x /home/tom/Dropbox/apps/memos/memos\nsudo chmod 644 /etc/systemd/system/memos.service\nsudo systemctl daemon-reload\nsudo systemctl start memos\nsystemctl status memos\nsudo systemctl stop memos\nsudo systemctl enable memos\nsudo systemctl disable memos\n參考\n\nLinux 建立自訂 Systemd 服務教學與範例\n"},"使用-API-Blueprint-寫文件":{"slug":"使用-API-Blueprint-寫文件","filePath":"使用 API Blueprint 寫文件.md","title":"使用 API Blueprint 寫文件","links":[],"tags":[],"content":"API Blueprint 是一種 markdown 語法的擴充，用來寫 RESTful API 文件\n工具\nAPI Blueprint 官網有列出許多工具，推薦網站Apiary。免費註冊後就能在線上編輯文件，左右對照 Markdown 和預覽結果，對於屬性有完整支援。\nAglio 則用來把 Markdown 轉成 HTML，安裝與使用方法如下：\n# 在 Debian 11 上安裝\n \n# 先安裝 Node.js\nsudo apt install curl build-essential\ncurl -sL deb.nodesource.com/setup_16.x | sudo bash -\nsudo apt install nodejs\n \nnode -v\nnpm -v\n \n# 使用 npm 全域安裝\nsudo npm install -g aglio\n \n# 也可以用 yarn 安裝\n# 安裝 yarn\nsudo apt install curl gnupg\ncurl -sS dl.yarnpkg.com/debian/pubkey.gpg | sudo apt-key add -\necho &quot;deb dl.yarnpkg.com/debian/ stable main&quot; | sudo tee /etc/apt/sources.list.d/yarn.list\nsudo apt-get update\nsudo apt-get install yarn\nyarn --version\n \n# 使用 yarn 全域安裝\nsudo yarn global add aglio\n接著編輯好 markdown 檔案，例如 example.md，然後執行 aglio -i example.md -o example.html ，轉換成 example.html。可以執行 aglio 指令看看參數有哪些。可以使用 aglio -i example.md -s -h 0.0.0.0 -p 8000 產生即時預覽。\n語法\n以下筆記參考自官方文件的範例\n開始\nFORMAT: 1A\nHOST: api.example.com/v1\n \n# The Simplest API\nThis is one of the simplest APIs written in the **API Blueprint**. One plain\nresource combined with a method and that&#039;s it! We will explain what is going on\nin the next installment -\n[Resource and Actions](02.%20Resource%20and%20Actions.md).\n開頭的 FORMAT: 1A 表示文件格式是 markdown，不寫也可以。\nHOST 表示 API 所在的網站網址，如果有一個路由是 GET /users，在 aglio 的示範會顯示爲 GET api.example.com/v1/users。HOST 可以不寫，則示範會顯示爲 GET /users\n接著一定要有一個 h1 標題（# The Simplest API）作爲文件主標題，一般是說明這是哪一個 API 文件，標題下方可以加上摘要描述，寫法和一般的markdown 一樣。\n# GET /message\n+ Response 200 (text/plain)\n \n        Hello World!\n這是一個簡單的例子，說明 HTTP 請求與回應。# 之後的是 HTTP method GET 和 RESTful 資源 /message，回應則寫成 + Response，使用了 markdown 的無序清單語法 +（清單可用 +、- 或 * 開頭），Response 後面接著是 HTTP 狀態碼 200 和 Content-Type text/plain（要寫在小括號內），最後回應的 body 則用 markdown 的 code 區塊語法表示，所以 Hello World 前面要有 8 個空格或是 2 個 Tab，或是用成對的三個 ` 包起來，不過一般都是用空格或 Tab，之後會看到，那是因爲 body 會和 Headers 等其它設定構成巢狀結構。\n資源與動作\n上一個例子中，定義了一個路由 GET /message 放在 h1 標題裡，如果有另一個路由 PUT /message，可以放在另一個 h1 標題裡，但是 /message 重複了，所以更好的方式是定義一個資源 /message，裏面包含 2 個動作 GET 和 PUT。如果日後需要修改資源，只要修改一個地方就好，減少產生 bug 的機會。\n# /message\n在這裡定義了一個資源 `/message`\n \n## GET\n裡面定義了動作 GET，所以等同於路由 GET /message\n \n+ Response 200 (text/plain)\n \n        Hello World!\n \n## PUT\n這裡是另一個動作 PUT，等同於路由 PUT /message，用來修改資料。\n \n+ Request (text/plain)\n \n        All your base are belong to us.\n \n+ Response 204\n動作 PUT 中定義了 HTTP 請求，和回應一樣使用 markdown 的無序清單語法 +，後面接著 Request，括號內是請求的標題欄位 Accept text/plain，表示可接受的回應 body 類型是純文字。請求的 body 和回應一樣使用 markdown 的 code 區塊語法，所以 All your base are belong to us. 的前面要有 8 個空格或 2 個 Tab，最後是回應 + Response 204，狀態碼 204 表示 No Content，表示修改完成，回應的 body 沒有內容。\n命名資源與動作\n# 訊息 [/message]\n資源 /message 取名爲訊息\n \n## 接收訊息 [GET]\nGET /message 的名稱是接收訊息。\n \n## 更新訊息 [PUT]\nPUT /message 的名稱是更新訊息。\n可以爲資源取一個名稱，方便識別，則名稱在# 之後，資源和動作改成放在中括號裡。名稱可以用中文。\n群組\n可以把多個資源和動作包含在一個群組裡。\n# Group 訊息\n定義一個訊息群組\n \n## 訊息 [/message]\n \n### 接收訊息 [GET]\n \n### 更新訊息 [PUT]\n \n# Group Users\n關鍵字 Group 或 group 後面接著群組名稱（訊息），則之後的資源和動作都包含在這個群組之內，直到出現另一個群組。資源和動作的 # 可以維持原來的 # 訊息 [/message] 和 ## 接收訊息 [GET]，改成如上這樣是爲了閱讀 markdown 時了解階層關係，是比較好的做法。\n回應\n定義標頭和回應的方式如下：\n# GET /message\n \n+ Response 200 (text/plain)\n這個是純文字回應\n \n    + Headers\n \n            X-My-Message-Header: 42\n \n    + Body\n \n            Hello World!\n \n+ Response 200 (application/json)\n這個是 JSON 回應\n \n    + Headers\n \n            X-My-Message-Header: 42\n \n    + Body\n \n            { &quot;message&quot;: &quot;Hello World!&quot; }\n \n一個路由有兩個回應，指定 body 是純文字或 JSON。回應的格式是 + Response 狀態碼 (Content-Type)，標頭 Headers 和內容 Body 是回應的內含資訊，所以用巢狀無序清單，必須向內縮至少一個空格，慣例是 4 個空格或 1 個 Tab；X-My-Message-Header: 42 和 Hello World! 都使用 code 區塊，必須向內縮止至少 8 個空格或 2 個 Tab，再加上 Header 或 Body 的縮排，所以是 12 個空格或 3 個 Tab。\n請求\n定義請求的方式如下：\n## 訊息 [/message]\n \n### 接收訊息 [GET]\n \n+ Request 純文字\n名稱是純文字的請求\n \n    + Headers\n \n            Accept: text/plain\n \n+ Response 200 (text/plain)\n \n    + Headers\n \n            X-My-Message-Header: 42\n \n    + Body\n \n            Hello World!\n \n+ Request JSON 訊息\n名稱是 JSON 訊息的請求\n \n    + Headers\n \n            Accept: application/json\n \n+ Response 200 (application/json)\n \n    + Headers\n \n            X-My-Message-Header: 42\n \n    + Body\n \n            { &quot;message&quot;: &quot;Hello World!&quot; }\n \n### 更新訊息 [PUT]\n2 種不同的更新請求：純文字和 JSON\n \n+ Request 更新文字訊息 (text/plain)\n \n        All your base are belong to us.\n \n+ Request 更新 JSON 訊息 (application/json)\n \n        { &quot;message&quot;: &quot;All your base are belong to us.&quot; }\n \n+ Response 204\n使用無序清單，例如 + 後面接著關鍵字 Request，然後標頭欄位 Accept 可以放在小括號內 (text/plain) 或是放在 Headers 內。\n可以爲請求取名，名稱放在 + Request 和小括號之間，可以用中文，但是回應不能取名。\n所以請求和回應很類似，都用 + 開頭，都有 + Headers 和 + Body 定義標頭和內容，都用小括號定義 Accept 或 Content-Type。\n不同的是請求可以取名，回應不行；回應要有 HTTP 狀態碼。\n參數 Parameters\n資源通常有 id 或關鍵字包含其中，例如 /users/123 或 /search?q=關鍵字，這時使用參數來定義。\n## 訊息 [/message/{id}]\n \n+ Parameters\n \n    + id: 1 (number) - 訊息的識別 ID\n \n## 所有訊息 [/messages{?limit}]\n \n### Retrieve all Messages [GET]\n \n+ Parameters\n \n    + limit (number, optional) - 回傳訊息的最大數量\n        + Default: `20`\n資源 /message/{id} 定義了一個名稱爲 id 的URI Template variable，使用大括號包起來，然後在底下的 + Parameters 定義 id 。\n同樣使用 markdown 的無序清單表示每一個項目，所以用 + 開頭，向內縮4 個空格或 1 個 Tab，然後格式是\n+ Parameters\n    + 名稱: 範例值 (型別, optional 或 required) - 描述(可用 markdown 語法)\n\n        額外的描述(可用 markdown 語法)\n\n        + Default: 預設值\n\n參數 Parameters 和之後會提到的屬性 Attributes、資料結構 Data Structures 都使用Markdown Syntax for Object Notation (MSON)的語法。\n\n名稱：參數的名稱，這是唯一必須要有的，其它都是可選的。\n範例值用來示範這個參數的值，有些 render 例如 aglio 會顯示在 URI，例如 GET /users/123\n型別：number, string, 或 boolean。預設是 string\noptional 或 required：表明這個參數是可選的或是必須要有的，預設是 required\n描述和額外的描述：描述參數的用途等資訊，可用 markdown 語法。額外的描述要向內縮 4 個空格或 1 個 Tab\n+ Default：預設值，沒有指定參數值時所用的值，只在參數設定爲 optional 時可用，可用 ` 包起值，確保可以正確轉換成 HTML，尤其是字串。要向內縮 4 個空格或 1 個 Tab\n\n資源模型 Resource Model\n可以把請求或回應的內容獨立出來，重複引用，名爲資源模型。\n## My Resource [/resource]\n \n+ Model (text/plain)\n \n        Hello World\n \n## My Message [/message]\n \n+ Model (application/vnd.siren+json)\n \n    一個 application/vnd.siren+json 訊息資源範例\n \n    + Headers\n \n            Location: api.acme.com/message\n \n    + Body\n \n            {\n              &quot;class&quot;: [ &quot;message&quot; ],\n              &quot;properties&quot;: {\n                    &quot;message&quot;: &quot;Hello World!&quot;\n              },\n              &quot;links&quot;: [\n                    { &quot;rel&quot;: &quot;self&quot; , &quot;href&quot;: &quot;/message&quot; }\n              ]\n            }\n \n### Retrieve a Message [GET]\n在回應和請求中引用\n \n+ Request 接收訊息的請求\n \n    [My Resource][]\n \n+ Response 200\n \n    [My Message][]\n \n上述有兩個資源模型，格式是 + Model (Content-Type)，底下必須要向內縮 4 個空格或 1 個 Tab，表示這些都隸屬於這個資源模型。第一個的內容是簡寫，表示 body 的內容是 Hello World，第二個定義在資源 My Message 中，內含說明、Headers 和 Body，然後在 + Request 或 + Response 向內縮 4 個空格或 1 個 Tab，使用 [資源名稱][] 引用它。\n資源模型中的小括號在請求或回應中都代表 Content-Type，所以 Accept 需要在 + Headers 中明確指出才行。不過即使如此，在請求和回應中，Accept 也不會覆蓋 Content-Type，而是兩者併呈。\n一個資源模型只能在資源中定義，而且一個資源只能有一個資源模型，所以上面的範例只有一個資源模型。模型本身不能像請求一樣命名，它使用資源的名稱作爲引用的名稱，所以沒有 + Model A (application/json) 這樣的寫法。\n引用使用的是 Markdown 的參考語法，不過第二個中括號要空著，否則無法引用。\nJSON Schema\nJSON Schema用來描述 JSON 的資料格式，例如欄位 name 的型別是字串，欄位 quantity 的型別是整數，方便自動測試。使用屬性 Attributes 時，會自動產生 Schema，你也可以手動輸入 Schema。\n+ Response 200 (application/json)\n \n    + Body\n \n            {\n                &quot;id&quot;: &quot;abc123&quot;,\n                &quot;title&quot;: &quot;This is a note&quot;,\n                &quot;content&quot;: &quot;This is the note content.&quot;\n                &quot;tags&quot;: [\n                    &quot;todo&quot;,\n                    &quot;home&quot;\n                ]\n            }\n \n    + Schema\n \n            {\n                &quot;type&quot;: &quot;object&quot;,\n                &quot;properties&quot;: {\n                    &quot;id&quot;: {\n                        &quot;type&quot;: &quot;string&quot;\n                    },\n                    &quot;title&quot;: {\n                        &quot;type&quot;: &quot;string&quot;\n                    },\n                    &quot;content&quot;: {\n                        &quot;type&quot;: &quot;string&quot;\n                    },\n                    &quot;tags&quot;: {\n                        &quot;type&quot;: &quot;array&quot;,\n                        &quot;items&quot;: {\n                            &quot;type&quot;: &quot;string&quot;\n                        }\n                    }\n                }\n            }\n使用 + Schema 手動輸入 JSON Schema，如上所示。apiary 自動產生的 JSON Schema 如下所示，所以 + Schema 手動輸入的內容會覆蓋掉屬性自動產生的 JSON Schema。\n{\n  &quot;$schema&quot;: &quot;json-schema.org/draft-07/schema#&quot;,\n  &quot;type&quot;: &quot;object&quot;,\n  &quot;properties&quot;: {\n    &quot;title&quot;: {\n      &quot;type&quot;: &quot;string&quot;\n    },\n    &quot;content&quot;: {\n      &quot;type&quot;: &quot;string&quot;\n    },\n    &quot;tags&quot;: {\n      &quot;type&quot;: &quot;array&quot;\n    }\n  }\n}\n之後的內容是在請求和回應的 body 中使用Markdown Syntax for Object Notation (MSON)描述 JSON 格式，aglio 沒有完整支援，而且使用 apiary 時只能把 MSON 轉成 JSON，稍微複雜一點的 JSON 就會需要更複雜的語法，所以我覺得直接寫 JSON 就好了，沒有必要多加一層語法。如果單純爲了避免重複程式碼，可以使用模型就好了，沒有必要使用接下來介紹的屬性和資料結構。\n屬性 Attributes\n請求或回應的 body 常常是重複的，可以用屬性 Attributes 來定義 body，然後在請求或回應中引用它。\n## 折價卷 [/coupons/{id}]\n折價卷資料。屬性定義在資源中如下：\n \n+ Parameters\n    + id (string)\n \n        折價卷 ID\n \n+ Attributes (object)\n    + id: 250FF (string, required)\n    + created: 1415203908 (number) - 新增時間戳\n    + percent_off: 25 (number)\n \n        打折的百分比，從 1 到 100\n \n    + redeem_by (number) - 兌換有效期限，此爲時間戳\n \n### 收到一張折價卷 [GET]\n \n+ Response 200 (application/json)\n    + Attributes (折價卷)\n \n### 新增一個折價卷 [POST]\n屬性也可以定義在請求和回應中：\n \n+ Request\n \n    + Attributes (object)\n \n        + percent_off: 25 (number)\n        + redeem_by (number)\n \n### 列出所有折價卷 [GET /coupons]\n \n+ Response 200 (application/json)\n    + Attributes (array[折價卷, 折價卷])\n屬性 Attributes 可以定義在資源或動作中，上面的例子裡，在資源折價卷中定義了一個屬性，有 4 個欄位，欄位的定義方式使用Markdown Syntax for Object Notation (MSON)，然後在動作 GET 的回應中使用 + Attributes (折價卷) 引用，會自動轉成 JSON，所以 body 會是如下所示：\n{\n  &quot;id&quot;: &quot;250FF&quot;,\n  &quot;created&quot;: 1415203908,\n  &quot;percent_off&quot;: 25,\n  &quot;redeem_by&quot;: 0\n}\n動作「新增一個折價卷」的請求定義了一個屬性作爲 body，所以屬性可以定義在請求和回應中作爲 body，但是寫法是如上所示，不是在 + Body 中內含 + Attributes，如下所示：\n+ Response 200 (application/json)\n\n    + Body\n\n        + Attributes (object)\n\n            + percent_off: 25 (number)\n            + redeem_by (number)\n\n不能引用自己內部定義的屬性。如下所示，在動作 get users 內定義的屬性，不能用在自己的回應中引用。\n# users [/users]\n \n## get users [GET]\n \n+ Attributes (object)\n  + name (string)\n  + email (string)\n \n+ Response 200 (application/json)\n  + Attributes (get users)\n資料結構 Data Structures\n屬性 Attributes 不一定要屬於某個資源或動作，可以單獨放到外面，名爲資料結構 Data Structures 的區塊中。\n### 收到折價卷 [GET /coupons]\n \n+ Response 200 (application/json)\n    + Attributes (折價卷)\n \n# Data Structures\n \n## 折價卷 (object)\n \n+ id: 250FF (string, required)\n+ created: 1415203908 (number) - 新增時間戳\n+ percent_off: 25 (number)\n \n    打折的百分比，從 1 到 100\n \n+ redeem_by (number) - 兌換有效期限，此爲時間戳\n上述放在折價卷資源中的屬性，改成放在資料結構中，則 + Attributes (object) 改成 ## 折價卷 (object)，內含的欄位 id, created, percent_off 和 redeem_by 都不變，只是沒有向內縮排\n請注意，使用 aglio 轉換時，如果在資源或動作中定義屬性，會沒有 body，但是在 Data Structures 定義就沒有這個問題。\n總結：屬性可以定義在資源、動作、請求與回應和資料結構，但是只能引用定義在其他資源和資料結構的屬性。\n繼承屬性\n屬性之間可以有類似類別的繼承關係，例如定義折價卷屬性基礎的 2 個欄位 percent_off 和 redeem_by，然後在需要時繼承它，再新增 2 個欄位\n### 收到折價卷 [GET /coupons]\n \n+ Response 200 (application/json)\n    + Attributes (折價卷)\n \n# Data Structures\n \n## 折價卷基礎 (object)\n \n+ percent_off: 25 (number)\n \n    打折的百分比，從 1 到 100\n \n+ redeem_by (number) - 兌換有效期限，此爲時間戳\n \n## 折價卷 (折價卷基礎)\n \n+ id: 250FF (string, required)\n+ created: 1415203908 (number) - 新增時間戳\n折價卷基礎先定義 2 個欄位 percent_off 和 redeem_by，然後折價卷屬性在小括號中指定繼承它，再新增 2 個欄位 id 和 created，資源中的屬性也能這樣繼承。\n{\n  &quot;percent_off&quot;: 25,\n  &quot;redeem_by&quot;: 0,\n  &quot;id&quot;: &quot;250FF&quot;,\n  &quot;created&quot;: 1415203908\n}\n子屬性折價卷的欄位會加在親屬性折價卷基礎的下方\n只有定義在資源和資料結構的屬性可以被引用，所以也只有這 2 個地方的屬性可以被繼承。"},"使用-Docker-Compose-安裝-Laravel-和-Vue.js-環境":{"slug":"使用-Docker-Compose-安裝-Laravel-和-Vue.js-環境","filePath":"使用 Docker Compose 安裝 Laravel 和 Vue.js 環境.md","title":"使用 Docker Compose 安裝 Laravel 和 Vue.js 環境","links":[],"tags":[],"content":"想要用 Docker 建立 Laravel 環境，於是 Google “Docker LEMP”，發現一篇很棒的文章Docker for local web development, introduction: why should you care?。因為不想每次忘記指令都回去看這一系列文章（英文沒那麼好），於是寫筆記。\n安裝 Docker\n安裝指令\n首先安裝 Docker，依照官方文件安裝即可，預設安裝 Docker 和 Docker Compose\n\nWindows：參考 Install Docker Desktop on Windows\nLinux：參考 Install Docker Engine on Debian 或選擇對應的發行套件\n\n如果是安裝在 Linux Mint，則用 Install Docker Engine on Ubuntu，在 Add the repository to Apt sources：\n# Add the repository to Apt sources:\necho \\\n  &quot;deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] download.docker.com/linux/ubuntu \\\n  $(. /etc/os-release &amp;&amp; echo &quot;${UBUNTU_CODENAME:-$VERSION_CODENAME}&quot;) stable&quot; | \\\n  sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null\n$(. /etc/os-release &amp;&amp; echo &quot;${UBUNTU_CODENAME:-$VERSION_CODENAME}&quot;) 在 Linux Mint 是無效的，所以上述的指令改成\necho \\\n  &quot;deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] download.docker.com/linux/ubuntu \\\n  jammy stable&quot; | \\\n  sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null\n\n對應到 Linux Mint Releases 的 Package base\nWSL\n如果在 WSL 安裝 Docker，可能會出現錯誤訊息：\n\n[sudo service docker start](docker: Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?.)\n\n原因是 docker 服務沒有啟動，所以：\n# 啟動 docker\nsudo service docker start\n# 檢查 docker 已啟動\nsudo service docker status\n# 開機時啟動 docker\nsudo systemctl enable docker\n不用 sudo\ndocker 預設使用 root 執行，其他使用者必須用 sudo，所以用以下指令讓一般使用者也能用 docker\n新增 docker 群組\nsudo groupadd docker\n把目前登入的使用者（$USER）加入 docker 群組\nsudo usermod -aG docker $USER\n重新登入，使得上面的指令生效，或者執行以下指令\nnewgrp docker\n如果上述方法無效，就重新啟動電腦\n使用的指令簡介\n依照 docker-compose.yaml 的設定新增並啟動容器，-d 參數表示在背景執行\ndocker compose up -d\n停止並刪除 docker compose 產生的容器和 volume（參數 -v）\ndocker compose down -v\n停止並刪除 docker compose 產生的容器、volume 和 image，自動略過仍被使用的 image\ndocker compose down -v --rmi all --remove-orphans\n顯示 docker-compose.yaml 相關的容器狀態(運作中、停止中)，-a 參數表示顯示包含停止中的容器\ndocker compose ps -a\n停止所有容器運作\ndocker compose stop\n要求 docker compose 在 php 容器上執行 bash，用來登入容器，登入後預設目錄是 docker 設定的 working_directory。指令 exit 離開容器\ndocker compose exec php bash\n顯示 nginx 容器的紀錄，如果省略 nginx 則顯示所有容器的紀錄。-f 代表持續監聽紀錄，按下 Ctrl + C 停止監聽\ndocker compose logs -f nginx\n新增 backend 容器並執行指令 php -m 後，刪除容器。php -m 指令顯示目前安裝的 php extension\ndocker compose run --rm backend php -m\n基本的 LEMP 環境\nNginx\n在專案目錄新增 docker-compose.yml，填入以下的設定\n# Services\nservices:\n \n  # Nginx Service\n  nginx:\n    # 使用 nginx 1.21 alpine 版本\n    image: nginx:1.21-alpine\n    # 本機的 port : 容器的 port\n    ports:\n      - 80:80\n執行 docker compose up -d 後，等待下載並新增容器後，用瀏覽器打開 http://localhost ，應該會看到 nginx 歡迎畫面\nPHP\ndocker-compose.yaml 更新如下\n# Services\nservices:\n \n  # Nginx Service\n  nginx:\n    image: nginx:1.21-alpine\n    ports:\n      - 80:80\n    volumes:\n      - ./src:/var/www/php\n      - ./.docker/nginx/conf.d:/etc/nginx/conf.d\n    depends_on:\n      - php\n \n  # PHP Service\n  php:\n    image: php:8.1-fpm\n    working_dir: /var/www/php\n    volumes:\n      - ./src:/var/www/php\nvolumes 用來同步本機和容器內的目錄與檔案，所以 ./src:/var/www/php 表示本機端的 ./src 目錄同步資料到容器內的 /var/www/php 目錄，src 目錄慣例用來放置應用程式原始碼\ndepends_on 確保 php-fpm 容器先成功新增，再來新增 nginx 容器，以免 nginx 容器回報找不到設定檔\n新增目錄 src 和 .docker/nginx/conf.d。一般把 docker 設定放在 .docker 目錄內\nmkdir -p src .docker/nginx/conf.d\nnginx 預設自動啟用 /etc/nginx/conf.d 目錄下所有副檔名為 conf 的設定檔，所以在本機端的 .docker/nginx/conf.d 目錄新增 php.conf 檔案，並填入 nginx 虛擬主機設定如下，讓 nginx 把 php 檔的請求轉給 php-fpm 處理。\nserver {\n    listen 80 default_server;\n    listen [::]:80 default_server;\n    root   /var/www/php;\n    index  index.php;\n\n    location ~* \\.php$ {\n        fastcgi_pass   php:9000;\n        include        fastcgi_params;\n        fastcgi_param  SCRIPT_FILENAME $document_root$fastcgi_script_name;\n        fastcgi_param  SCRIPT_NAME     $fastcgi_script_name;\n    }\n}\n\n注意以上的 fastcgi_pass   php:9000; 設定，docker compose 自動建立內部網路並設定所有容器的 /etc/hosts 檔案，所以可以用 php 代表容器內部 ip，就像用 localhost 代表 127.0.0.1。\n執行 docker compose down 停止並刪除之前的 nginx 容器，執行 docker compose up -d 新增並啟動容器。執行 docker compose logs 顯示紀錄檢查一下是否有錯誤，在 src 目錄新增 index.php，輸入程式碼如下\n&lt;?php\nphpinfo();\n然後在瀏覽器打開 http://localhost/ 應該會看到熟悉的 php 設定頁面\nMariaDB\ndocker-compose.yaml 修改成如下\n# Services\nservices:\n \n  # Nginx Service\n  nginx:\n    image: nginx:1.21-alpine\n    ports:\n      - 80:80\n    volumes:\n      - ./src:/var/www/php\n      - ./.docker/nginx/conf.d:/etc/nginx/conf.d\n    depends_on:\n      - php\n \n  # PHP Service\n  php:\n    build: ./.docker/php\n    working_dir: /var/www/php\n    volumes:\n      - ./src:/var/www/php\n \n  # MariaDB Service\n  mariadb:\n    image: mariadb:latest\n    environment:\n      - MARIADB_DATABASE=demo\n      - MARIADB_USER=demo\n      - MARIADB_PASSWORD=$MARIADB_PASSWORD\n      - MARIADB_RANDOM_ROOT_PASSWORD=1\n    volumes:\n      - mariadbdata:/var/lib/mysql\n    ports:\n      - 127.0.0.1:3306:3306\n \n \n# Volumes\nvolumes:\n \n  mariadbdata:\n需要 pdo_mysql extension 讓 PHP 查詢 MySQL，php-fpm 官方 image 沒有內建，但是有 docker-php-ext-install 指令來安裝 php 的 extension，所以 php 改用 Dockerfile 建立自訂的 docker image\n新增目錄 .docker/php\nmkdir -p .docker/php\n然後新增 Dockerfile 檔案到 .docker/php 目錄，填入以下設定\nFROM php:8.1-fpm-alpine\n\nRUN docker-php-ext-install pdo_mysql\n\n原文使用 mysql/mysql-server，不過好像不能用了，老是顯示為 Error，所以改用 MariaDB。\nMARIADB_PASSWORD=$MARIADB_PASSWORD 表示使用 .env 的 MARIADB_PASSWORD 值做為密碼，root 密碼則是自動亂數產生，表示不使用 root 登入。不須像原文那樣設定 my.cnf，使用 MariaDB 預設值即可。不再使用 healthy check ，實在太慢了。\n新增檔案 .env，設定 MariaDB 密碼\nMARIADB_PASSWORD=&#039;密碼&#039;\n\n前端 Vue.js 與後端 Laravel\n後端 Laravel\n建立所需的 image 和權限\n如果從前面的設定一路到此，需要刪除 .docker/php 目錄，以及檔案 .docker/nginx/conf.d/php.conf 和 src/index.php，目錄結構應該從以下那樣開始(執行 tree -a . 指令的結果)\n├── .docker\n│   └── nginx\n│       └── conf.d\n├── docker-compose.yaml\n├── .env\n└── src\n\n修改 docker-compose.yaml 如下\n# Services\nservices:\n \n  # Nginx Service\n  nginx:\n    image: nginx:1.21-alpine\n    ports:\n      - 80:80\n    volumes:\n      - ./src/backend:/var/www/backend\n      - ./.docker/nginx/conf.d:/etc/nginx/conf.d\n    depends_on:\n      - backend\n \n  # Backend Service\n  backend:\n    build:\n      context: ./src/backend\n      args:\n        HOST_UID: $HOST_UID\n    working_dir: /var/www/backend\n    volumes:\n      - ./src/backend:/var/www/backend\n \n  # MariaDB Service\n  mariadb:\n    image: mariadb:latest\n    environment:\n      - MARIADB_DATABASE=demo\n      - MARIADB_USER=demo\n      - MARIADB_PASSWORD=$MARIADB_PASSWORD\n      - MARIADB_RANDOM_ROOT_PASSWORD=1\n    volumes:\n      - mariadbdata:/var/lib/mysql\n    ports:\n      - 127.0.0.1:3306:3306\n \n \n# Volumes\nvolumes:\n \n  mariadbdata:\n修改的地方有：\n\nnginx 的 volumes：- ./src:/var/www/php 改為 - ./src/backend:/var/www/backend\nphp 整個改成 backend\n\n在 .docker/nginx/conf.d 目錄新增檔案 backend.conf，填入以下內容\nserver {\n    listen      80;\n    listen      [::]:80;\n    root        /var/www/backend/public;\n\n    add_header X-Frame-Options &quot;SAMEORIGIN&quot;;\n    add_header X-Content-Type-Options &quot;nosniff&quot;;\n\n    index index.php;\n\n    charset utf-8;\n\n    location / {\n        try_files $uri $uri/ /index.php$query_string;\n    }\n\n    location = /favicon.ico { access_log off; log_not_found off; }\n    location = /robots.txt  { access_log off; log_not_found off; }\n\n    error_page 404 /index.php;\n\n    location ~ \\.php$ {\n        fastcgi_pass  backend:9000;\n        fastcgi_param SCRIPT_FILENAME $realpath_root$fastcgi_script_name;\n        include       fastcgi_params;\n    }\n\n    location ~ /\\.(?!well-known).* {\n        deny all;\n    }\n}\n\n新增 src/backend 目錄\nmkdir -p src/backend\n在 src/backend 目錄內新增 Dockerfile，並填入以下內容\nFROM php:8.1-fpm-alpine\n \n# Install extensions\nRUN docker-php-ext-install pdo_mysql bcmath\n \n# Install Composer\nCOPY --from=composer:latest /usr/bin/composer /usr/local/bin/composer\n \n# Create user based on provided user ID\nARG HOST_UID\nRUN adduser --disabled-password --gecos &quot;&quot; --uid $HOST_UID demo\n \n# Switch to that user\nUSER demo\n使用 multi-stage build 方式直接複製檔案來安裝 Composer\nDockerfile 新增使用者 demo，並切換到 demo，這是為了讓之後新增的 Laravel 檔案權限是一般使用者，否則預設是 root。\n執行以下的指令，顯示目前本機的使用者 uid\nid -u\n然後在 .env 中設定環境變數\n# 假設 id -u 的結果是 1000\nHOST_UID=1000\n\n最後執行 docker compose build backend 建立 image\n新增 Laravel 專案\n新增 Laravel 專案 tmp，然後把 tmp 目錄內的檔案移出來，這樣 src/backend/ 目錄內才會是 Laravel 檔案\ndocker compose run --rm backend composer create-project --prefer-dist laravel/laravel tmp &quot;10.*&quot;\n \ndocker compose run --rm backend sh -c &quot;mv -n tmp/.* ./ &amp;&amp; mv tmp/* ./ &amp;&amp; rm -Rf tmp&quot;\n修改 src/backend/ 目錄的 .env 檔案，讓資料庫設定正確\nDB_CONNECTION=mysql\n# 要用 docker container 名稱 mariadb，不是用 127.0.0.1\nDB_HOST=mariadb\nDB_PORT=3306\n# 因為 docker compose 的 MYSQL_DATABASE 設定是 demo\nDB_DATABASE=demo\nDB_USERNAME=demo\n# .env 和 src/backend/.env 的 MARIADB_PASSWORD 設定值要一樣\nDB_PASSWORD=密碼\n\ndocker compose down -v 刪除容器。docker compose up -d 新增容器，docker compose ps -a 確認容器正常運作\n執行指令 docker compose exec backend php artisan migrate 確認資料庫設定正確\nOPcache\n在 src/backend 目錄新增 .docker 目錄\nmkdir -p src/backend/.docker\n在 src/backend/.docker 新增 php.ini 檔案，填入以下內容\n[opcache]\nopcache.enable=1\nopcache.revalidate_freq=0\nopcache.validate_timestamps=1\nopcache.max_accelerated_files=10000\nopcache.memory_consumption=192\nopcache.max_wasted_percentage=10\nopcache.interned_strings_buffer=16\nopcache.fast_shutdown=1\n\n修改 src/backend 目錄內的 Dockerfile 如下\nFROM php:8.1-fpm-alpine\n\n# Install extensions\nRUN docker-php-ext-install pdo_mysql bcmath opcache\n\n# Install Composer\nCOPY --from=composer:latest /usr/bin/composer /usr/local/bin/composer\n\n# Configure PHP\nCOPY .docker/php.ini $PHP_INI_DIR/conf.d/opcache.ini\n\n# Use the default development or production configuration\nARG APP_ENV\nRUN mv $PHP_INI_DIR/php.ini-$APP_ENV $PHP_INI_DIR/php.ini\n\n# Create user based on provided user ID\nARG HOST_UID\nRUN adduser --disabled-password --gecos &quot;&quot; --uid $HOST_UID demo\n\n# Switch to that user\nUSER demo\n\ndocker-compose.yaml 需要設定 args APP_ENV\nbackend:\n    build:\n      context: ./src/backend\n      args:\n        HOST_UID: $HOST_UID\n        APP_ENV: $APP_ENV\n設定 .env\n# development 或是 production\nAPP_ENV=&#039;development&#039;\n\n最後執行 docker compose build backend 建立 image，docker compose up -d 新增並啟動容器\n執行 docker compose exec backend php -m 確認有啟用 Zend OPcache\n安裝 Redis\n修改 src/backend 目錄內的 Dockerfile，新增以下內容\n# Install Redis extension\nRUN apk add --no-cache pcre-dev $PHPIZE_DEPS \\\n    &amp;&amp; pecl install redis 6.0.0 \\\n    &amp;&amp; docker-php-ext-enable redis\n\n執行 docker compose build backend 建立 image\n修改 docker-compose.yaml，新增以下內容\n# Redis Service\nredis:\n  image: redis:6-alpine\n  command: [&quot;redis-server&quot;, &quot;--appendonly&quot;, &quot;yes&quot;]\n  volumes:\n    - redisdata:/data\ncommand 用來覆蓋容器啟動後的預設指令。Redis 在此是用來執行佇列，最好保存排程紀錄，所以設定成 Append Only File 模式 (--appendonly 參數)\n需要保存 redis 資料，所以新增一個 volume\nvolumes:\n  redisdata:\n因為 Redis 是給 backend 容器使用的，所以在 backend depends_on 新增以下內容，確保先啟動 Redis 容器\n  depends_on:\n    redis:\n      condition: service_started\n修改 src/backend 目錄內的 .env，redis host 要和資料庫一樣改用 docker 內部別名，所以改成以下這樣\nQUEUE_CONNECTION=redis\nREDIS_HOST=redis\n\n執行指令 docker compose up -d 新增並啟動容器\n佇列 queue\n接下來會有兩個執行 Laravel 的容器，一個執行一般的 web 請求，另一個執行佇列，因為兩個容器需要的 Dockerfile 很類似，所以用以下的方式\n修改 src/backend 目錄內的 Dockerfile，開頭的 FROM php:8.1-fpm-alpine 加上 as backend，把這一行開始到另一個 FROM 之前的階段取名為 backend\nFROM php:8.1-fpm-alpine as backend\n\n以及以 backend 階段為基礎，取新的名稱 worker，在 Dockerfile 最底下新增以下的 FROM 和 CMD 內容\nFROM backend as worker\n\n# Start worker\nCMD [&quot;php&quot;, &quot;/var/www/backend/artisan&quot;, &quot;queue:work&quot;]\n\nCMD 指令設定 worker 容器啟動後自動執行 php artisan queue:work\n修改 docker-compose.yaml，新增以下設定\n# Worker Service\nworker:\n  build:\n    context: ./src/backend\n    target: worker\n    args:\n      HOST_UID: $HOST_UID\n      APP_ENV: $APP_ENV\n  working_dir: /var/www/backend\n  volumes:\n    - ./src/backend:/var/www/backend\n  depends_on:\n    - backend\n上面的設定和 backend 容器很像，也用 volume 同步相同的 Laravel 檔案，唯一不同的是因為共用同一個 Dockerfile，所以要用 target: worker 指定使用的是 worker 階段。\n因此 backend 容器也要加上 target: backend，指定使用 backend 階段\n# Backend Service\nbackend:\n  build:\n    context: ./src/backend\n    target: backend\n    args:\n      HOST_UID: $HOST_UID\n      APP_ENV: $APP_ENV\n建立兩個 image，所以執行兩個 build\ndocker compose build backend\ndocker compose build worker\n最後執行指令 docker compose up -d 新增並啟動容器\n前端 Vue.js\n建立所需的 image 和權限\ndocker-compose.yaml 填入以下內容\n# Frontend Service\nfrontend:\n  build: ./src/frontend\n  working_dir: /var/www/frontend\n  volumes:\n    - ./src/frontend:/var/www/frontend\n  depends_on:\n    - backend\n以及在 nginx 的 depends_on 加上 - frontend\n在 src 目錄新增 frontend 目錄\nmkdir -p src/frontend\n然後新增 Dockerfile 檔案，填入以下設定\nFROM node:20-alpine\n\nUSER node\n\n切換到使用者 node，否則新增 Vue.js 專案的檔案權限預設是 root。在 Docker for local web development, part 3: a three-tier architecture with frameworks 沒有如此設定，所以其實會產生問題\n執行指令 docker compose build frontend 建立 image\n新增 Vue.js 專案\n新增 Vue.js 專案 tmp，然後把 tmp 目錄內的檔案移出來，這樣 src/frontend/ 目錄內才會是 Vue.js 檔案\ndocker compose run --rm frontend yarn create vite tmp --template vue\n \ndocker compose run --rm frontend sh -c &quot;mv -n tmp/.* ./ &amp;&amp; mv tmp/* ./ &amp;&amp; rm -Rf tmp&quot;\n安裝 Vue.js 依賴的套件\ndocker compose run --rm frontend yarn\n在 .docker/nginx/conf.d 目錄新增 frontend.conf 檔案，填入以下設定\nserver {\n    listen      80;\n    listen      [::]:80;\n\n    location / {\n        proxy_pass         http://frontend:8080;\n        proxy_http_version 1.1;\n        proxy_set_header   Upgrade $http_upgrade;\n        proxy_set_header   Connection &#039;upgrade&#039;;\n        proxy_cache_bypass $http_upgrade;\n        proxy_set_header   Host $host;\n    }\n}\n\n上述設定連到 http://localhost ，會把請求轉到 frontend 容器處理，所以後端的 nginx 設定要改成 port 8000，否則會衝突，連到後端 Laravel\n修改 .docker/nginx/conf.d 目錄內的 backend.conf 檔案，把 port 改成 8000\nserver {                                                                        \n    listen      8000;                                                            \n    listen      [::]:8000;                                                       \n    root        /var/www/backend/public;    \n\n\n還有 docker-compose.yaml 要修改 nginx ports，開放 8000\n  nginx:\n    image: nginx:1.21-alpine\n    ports:\n      - 80:80\n      - 8000:8000\n因為 nginx 設定成 port 80 直接轉到容器內部網址 http://frontend:8080 （使用 proxy_pass），由 Vite 提供 HTTP server，Vue.js 檔案不需要同步到 nginx，但是後端是交給 nginx 作為 HTTP server，轉交 php 請求給 php-fpm（使用 fastcgi_pass），php-fpm 會去找設定的 root 目錄中有沒有請求指定的 php 檔案，注意是檔案，不是網址，所以 src/backend 目錄的檔案需要同步給 nginx 。\n在正式環境，直接打包 JavaScript 檔案，交給 nginx 做為一般的靜態檔案，所以不需要前端容器\n在 src/frontend 新增 vite.config.js 檔案，填入以下設定，設置好 Vite 的 hot reload\nimport { defineConfig } from &#039;vite&#039;\nimport vue from &#039;@vitejs/plugin-vue&#039;\n \nexport default defineConfig({\n    plugins: [vue()],\n    server: {\n        host: true,\n        hmr: {port: 80},\n        port: 8080,\n        watch: {\n            usePolling: true\n        }\n    }\n})\n修改 src/frontend 目錄內的 Dockerfile 檔案，新增 yarn dev 指令，使容器啟動後自動執行測試環境\nFROM node:20-alpine\n \nUSER node\n \n# Start application\nCMD [&quot;yarn&quot;, &quot;dev&quot;]\n修改了 Dockerfile，所以要執行指令 docker compose build frontend 重建 image\n最後執行指令 docker compose up -d，用瀏覽器打開 http://localhost 應該可以看到 Vue.js 的歡迎頁面\n排程\n文章中推薦使用 Ofelia ，好處是如果要修改執行的週期、容器或指令，只需要修改 config.ini 設定，並重新啟動 Ofelia 容器即可。如果用 Linux cron，Google 了一下發現相當麻煩，這篇文章如何在 Docker 中運行 Cron？ 可以參考\n在 .docker 目錄內新增 scheduler 目錄\nmkdir -p .docker/scheduler\n然後在 .docker/scheduler 目錄內新增檔案 config.ini，填入以下設定\n[job-exec &quot;Laravel Scheduler&quot;]\nschedule = @every 1m\ncontainer = demo-backend-1\ncommand = php /var/www/backend/artisan schedule:run\n\n以上設定名稱為 demo-backend-1 的容器每分鐘執行一次 php /var/www/backend/artisan schedule:run 指令\n修改 docker-compose.yaml，新增以下內容\n# Scheduler Service\nscheduler:\n  image: mcuadros/ofelia:latest\n  volumes:\n    - /var/run/docker.sock:/var/run/docker.sock\n    - ./.docker/scheduler/config.ini:/etc/ofelia/config.ini\n  depends_on:\n    - backend\n執行 docker compose up -d 指令，新增並啟動容器，執行 docker compose logs -f scheduler 指令，確認 Ofelia 容器正常運作\nPS. 可能需要設定 backend container_name:demo-backend ，以及修改 .docker/scheduler/config.ini 的 container 為 demo-backend。因為 docker container 名稱會用到資料夾名稱"},"使用-docker-執行-node.js":{"slug":"使用-docker-執行-node.js","filePath":"使用 docker 執行 node.js.md","title":"使用 docker 執行 node.js，問 AI 語法","links":[],"tags":[],"content":"用 docker 執行 node.js 環境，先從 shell 開始，因為需要執行 node file.js。一般是用 docker run 如下所示\ndocker run --rm -it node:22-alpine /bin/sh\n怎麼改用 docker compose 實作呢？\n我平常只用 AI 來翻譯英文，和做一些市場調查，例如問它「網站後端程式語言市占率」，想說問問看「請將 docker run —rm -it node:22-alpine /bin/sh 改用 docker compose」，結果如下：\nChatGPT\n你可以使用 Docker Compose 來達成等效於 docker run --rm -it node:22-alpine /bin/sh 的效果。這裡的重點是：\n\n使用 node:22-alpine 映像\n進入一個互動式 shell\n容器在結束後自動移除（--rm）\n\n雖然 Docker Compose 本身沒有 --rm 的選項，但你可以透過 docker compose run 搭配 --rm 來達成類似效果。\n\n方法一：使用 docker-compose.yml 搭配 docker compose run\n建立一個 docker-compose.yml 檔案如下：\nservices:\n  node:\n    image: node:22-alpine\n    stdin_open: true       # 等同於 -i\n    tty: true              # 等同於 -t\n然後執行這個指令：\ndocker compose run --rm node /bin/sh\n\n方法二：使用 docker compose exec（需先啟動）\n如果你想用 exec，必須先 docker compose up 啟動服務，範例如下：\ndocker compose up -d\ndocker compose exec node /bin/sh\n但這樣就不會自動刪除容器了，不等同於 --rm。\n\n補充：如果只是一次性使用，其實用原本的 docker run --rm -it 會比較簡單。但如果你需要頻繁使用或整合到其他 Compose 設定中，以上方法會比較合適。\n需要我幫你加入 volume 或 mount 目前目錄嗎？\nGoogle Gemini\n您可以透過以下 docker-compose.yml 檔案來實現 docker run --rm -it node:22-alpine /bin/sh 的功能：\nYAML\nversion: &#039;3.8&#039;\nservices:\n  node-shell:\n    image: node:22-alpine\n    stdin_open: true # 等同於 -i\n    tty: true        # 等同於 -t\n    command: /bin/sh\n    # 若您希望容器停止後自動移除，可以加上以下這行，但請注意這在 docker compose 服務運行時可能不那麼常見，因為通常服務會持續運行。\n    # restart: &quot;no&quot; # 或者不設定 restart，預設行為在容器停止後不會自動重啟。\n    # 由於 docker compose 預設不會在服務停止後移除容器，若要達到 --rm 的效果，需要手動執行 docker compose down --volumes --rmi all\n\n\n如何使用這個 docker-compose.yml 檔案：\n\n\n儲存檔案： 將上述內容儲存為 docker-compose.yml 在您希望的位置。\n\n\n啟動服務： 在終端機中，導航到 docker-compose.yml 檔案所在的目錄，然後執行以下命令：\nBash\ndocker compose run --rm node-shell\n這個命令會啟動 node-shell 服務，並在容器退出後自動移除容器（--rm 參數）。它會直接在 node-shell 服務中執行 command 定義的 /bin/sh，並提供互動式終端機。\n\n\n\n與 docker run 命令的對應關係：\n\nimage: node:22-alpine：指定使用的 Docker 映像檔。\nstdin_open: true (-i)：保持標準輸入開放，即使沒有附加到它。\ntty: true (-t)：分配一個偽 TTY，這對於互動式 Shell 是必需的。\ncommand: /bin/sh：指定容器啟動時要執行的命令，這就是您要進入的 Shell。\ndocker compose run --rm：這個命令本身就提供了 docker run 中的 --rm 功能，會在命令執行完畢後自動移除容器。\n\n\n小提醒：\n\ndocker compose 主要用於管理多個服務的應用程式，通常服務會設計為長時間運行。而 docker run --rm -it 更多是用於臨時性的、一次性的容器操作，例如進入容器執行特定命令或調試。\n如果您只是想快速進入一個臨時容器的 Shell，docker run 可能是更直接和快速的方式。而 docker compose 則提供了一個更結構化、更可重複的方式來定義和運行容器環境。\n\n這樣設定後，您就可以使用 docker compose 來進入 node:22-alpine 容器的 Shell 了。\n感想\n最後採用 ChatGPT 的方法二：使用 docker compose exec（需先啟動），因為我需要每天都執行 node.js ，但是不想要頻繁的新增和刪除容器。第一次用 ChatGPT 時，就感覺是比較高級的搜尋引擎，顯示的結果令人驚艷，但是還是要能理解內容才能拿來用，例如還是會 docker 才能使用上述的結果，看不懂就沒辦法了。\n新增檔案 docker-compose.yaml 如下：\nservices:\n  node:\n    image: node:22-alpine\n    stdin_open: true\n    tty: true\n    volumes:\n      - ./src:/app\n    working_dir: /app\n    restart: &quot;no&quot;\n新增並啟動容器，連線至容器後執行 /bin/sh\ndocker compose up -d\ndocker compose exec node /bin/sh"},"在-Dedian-11-安裝-LEMP-開發環境跑-Laravel-10":{"slug":"在-Dedian-11-安裝-LEMP-開發環境跑-Laravel-10","filePath":"在 Dedian 11 安裝 LEMP 開發環境跑 Laravel 10.md","title":"在 Dedian 11 安裝 LEMP 開發環境跑 Laravel 10","links":[],"tags":[],"content":"摘要\n這個是在 VirtualBox 6 新增虛擬機器，裝好 Debian 11 後，安裝 LEMP 的過程，最後安裝 Laravel 10 來寫網站後端\n下載 debian-11.8.0-amd64-netinst.iso\n安裝 PHP-FPM 8.3\nsudo apt -y install lsb-release apt-transport-https ca-certificates wget gnupg\nsudo wget -O /etc/apt/trusted.gpg.d/php.gpg packages.sury.org/php/apt.gpg\necho &quot;deb packages.sury.org/php/ $(lsb_release -sc) main&quot; | sudo tee /etc/apt/sources.list.d/php.list\nsudo apt update; sudo apt upgrade -y\n \nPHP_VERSION=&#039;8.3&#039;\nsudo apt install -y php$PHP_VERSION-{cli,fpm,common,gd,mbstring,curl,bcmath,opcache}\n設定 PHP-FPM\n# 備份 php-fpm 池設定\nsudo cp /etc/php/$PHP_VERSION/fpm/pool.d/www.conf \\\n  /etc/php/$PHP_VERSION/fpm/pool.d/www.conf.sample\nsudo vim /etc/php/$PHP_VERSION/fpm/pool.d/www.conf\n改成以下的設定\nuser = tom\ngroup = tom\nlisten = 127.0.0.1:9000\nlisten.allowed_clients = 127.0.0.1\nslowlog = /home/tom/apps/logs/slow.log\nrequest_slowlog_timeout = 5s\n建立上述設定需要的資料夾和權限\nmkdir -p /home/tom/apps/logs/\nsudo chown -R tom:tom /home/tom/apps/logs/\n重新啟動 PHP-FPM\nsudo service php$PHP_VERSION-fpm restart\nnginx\n安裝\nsudo apt install -y nginx\n# 檢查 nginx 是否正常啟動。按 q 離開\nsudo systemctl status nginx\n瀏覽 http://192.168.56.10 應該會看到  Welcome to nginx!\n\n網址是 http://192.168.56.10 ，表示這個虛擬環境有設定 host-only 網路\n\n設定\n新增設定需要的目錄。在使用者 tom 的 home 目錄新增 apps 目錄\nmkdir -p /home/tom/apps/logs/localhost\nmkdir -p /home/tom/apps/localhost/current/public\nsudo chown tom:tom /home/tom/apps/logs/slow.log\n編輯 nginx 設定\nsudo vim /etc/nginx/sites-available/default\n以下設定取消註解\n location ~ \\.php$ {\n    include snippets/fastcgi-php.conf;\n\n    fastcgi_pass 127.0.0.1:9000;\n  }\n\n啟用上述設定，重開 nginx，並查看 nginx 是否正常運作\nsudo service nginx restart\nsudo systemctl status nginx\n編輯 info.php 檔案\nsudo vim /var/www/html/info.php\n複製貼上以下程式碼\n&lt;?php phpinfo();\n瀏覽 http://192.168.56.10/info.php ，應該會看到 PHP Version 8.3 相關設定\n刪除 info.php 檔案\nsudo rm /var/www/html/info.php\n前端編譯用程式\nnode.js\nsudo apt install -y curl build-essential\ncurl -sL deb.nodesource.com/setup_20.x | sudo bash -\nsudo apt install -y nodejs\n \nnode -v\nnpm -v\nyarn\nsudo npm install --global yarn\nyarn --version\n安裝 composer\n複製貼上官網的指令\ngetcomposer.org/download/\n移到系統資料夾，並檢查是否可以全域呼叫\nsudo mv composer.phar /usr/local/bin/composer\ncomposer --version\n安裝 laravel\nsudo apt install -y zip unzip php$PHP_VERSION-{zip,xml,bcmath}\ncomposer global require &quot;laravel/installer&quot;\n \necho &#039;export PATH=~/.local/bin:~/.config/composer/vendor/bin:$PATH&#039; &gt;&gt; ~/.bash_profile\nsource ~/.bash_profile\n建立 Laravel 10 專案\ncd ~/apps\n \n# 安裝最新版本，project_name 改成想要的目錄名稱\nlaravel new project_name\n# 或者安裝指定版本 (10)，project_name 改成想要的目錄名稱\ncomposer create-project laravel/laravel=10.* project_name --prefer-dist\n \ncd project_name\n \n# 安裝相依的 PHP 套件\ncomposer install\n \n# 安裝前端編譯需要的套件\nyarn install\n之前執行 yarn dev 遇到問題，產生錯誤訊息\n\nError: ENOSPC: System limit for number of file watchers reached\n\n解決方法是修改 sysctl.conf 的設定\necho fs.inotify.max_user_watches=524288 | sudo tee -a /etc/sysctl.conf &amp;&amp; sudo sysctl -p\n# 應該顯示 524288\ncat /proc/sys/fs/inotify/max_user_watches\n上述方法來自於 React Native Error: ENOSPC: System limit for number of file watchers reached\n執行前端編譯與監視檔案變動\n# 按 q 離開\nyarn dev\n\n設定 nginx 執行 Laravel\n假設專案名稱是 project_name\nsudo vim /etc/nginx/sites-available/project_name.conf\n複製貼上以下設定。注意 root 要改成 Laravel 專案的絕對路徑，listen 8111 表示設定 port 是 8111\nserver {\n  listen 8111;\n  server_name 192.168.56.10;\n  index index.php index.html;\n  client_max_body_size 50M;\n  error_log /home/tom/apps/logs/localhost/error.log;\n  access_log /home/tom/apps/logs/localhost/access.log;\n  root /home/tom/apps/project_name/public;\n  location / {\n    try_files $uri $uri/ /index.php$is_args$args;\n  }\n  location ~ \\.php {\n    try_files $uri = 404;\n    fastcgi_split_path_info ^(.+\\.php)(/.+)$;\n    include fastcgi_params;\n    fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;\n    fastcgi_param SCRIPT_NAME $fastcgi_script_name;\n    fastcgi_index index.php;\n    fastcgi_pass 127.0.0.1:9000;\n  }\n}\n\n啟用設定，並重新啟動 nginx\nsudo ln -s /etc/nginx/sites-available/project_name.conf \\\n           /etc/nginx/sites-enabled/project_name.conf\nsudo systemctl restart nginx\n瀏覽 http://192.168.56.10:8111\n安裝 MariaDB\nsudo apt install -y mariadb-server php$PHP_VERSION-mysql\nsudo mysql_secure_installation\n接下來會回答一系列問題，下一行則是建議操作\nEnter current password for root (enter for none):\n按下 enter\nSwitch to unix_socket authentication [Y/n]\n按下 enter\nChange the root password? [Y/n] \n按下 n\nRemove anonymous users? [Y/n]\n按下 enter\nDisallow root login remotely? [Y/n]\n按下 enter\nRemove test database and access to it? [Y/n]\n按下 enter\nReload privilege tables now? [Y/n]\n按下 enter\n新增資料庫\nsudo mariadb\n執行以下 SQL 新增使用者 project_name 和資料庫 project_name(或換成想要的名稱)。記得密碼要修改（IDENTIFIED BY &#039;密碼&#039;）\nCREATE DATABASE project_name CHARACTER SET utf8mb4;\nCREATE USER &#039;project_name&#039;@&#039;localhost&#039; IDENTIFIED BY &#039;密碼&#039;;\nGRANT ALL PRIVILEGES ON project_name.* TO &#039;project_name&#039;@&#039;localhost&#039;;\nFLUSH PRIVILEGES;\nexit\n用編輯器打開 .env 檔案，修改以下設定。DB_DATABASE、DB_USERNAME 和密碼要改成剛剛設定的\nDB_CONNECTION=mysql\nDB_HOST=127.0.0.1\nDB_PORT=3306\nDB_DATABASE=project_name\nDB_USERNAME=project_name\nDB_PASSWORD=&#039;密碼&#039;\n\n執行 migration 測試設定是否正確\nphp artisan migrate"},"在-Dedian-12-安裝-LEMP-開發環境跑-Laravel-10":{"slug":"在-Dedian-12-安裝-LEMP-開發環境跑-Laravel-10","filePath":"在 Dedian 12 安裝 LEMP 開發環境跑 Laravel 10.md","title":"在 Dedian 12 安裝 LEMP 開發環境跑 Laravel 10","links":[],"tags":[],"content":"摘要\n這個是在 VirtualBox 7 新增虛擬機器，裝好 Debian 12 後，安裝 LEMP 的過程，最後安裝 Laravel 10 來寫網站後端\n安裝 PHP-FPM 8.3\nsudo apt -y install lsb-release apt-transport-https ca-certificates wget gnupg\nsudo wget -O /etc/apt/trusted.gpg.d/php.gpg packages.sury.org/php/apt.gpg\necho &quot;deb packages.sury.org/php/ $(lsb_release -sc) main&quot; | sudo tee /etc/apt/sources.list.d/php.list\nsudo apt update; sudo apt upgrade -y\n \nPHP_VERSION=&#039;8.3&#039;\nsudo apt install -y php$PHP_VERSION-{cli,fpm,common,gd,mbstring,curl,bcmath,opcache}\n \nsudo cp /etc/php/$PHP_VERSION/fpm/pool.d/www.conf \\\n  /etc/php/$PHP_VERSION/fpm/pool.d/www.conf.sample\nsudo vim /etc/php/$PHP_VERSION/fpm/pool.d/www.conf\n改成以下的設定\nuser = tom\ngroup = tom\nlisten = 127.0.0.1:9000\nlisten.owner = tom\nlisten.group = tom\nlisten.allowed_clients = 127.0.0.1\n\n重新啟動 PHP-FPM\nsudo service php$PHP_VERSION-fpm restart\nnginx\n安裝\nsudo apt install -y nginx\n \n# 檢查 nginx 是否正常啟動。按 q 離開\nsudo systemctl status nginx\n瀏覽 http://192.168.56.10 應該會看到 Welcome to nginx!\n\n網址是 http://192.168.56.10 ，表示這個虛擬環境有設定 host-only 網路\n\n編輯 nginx 設定\nsudo vim /etc/nginx/sites-available/default\n以下設定取消註解\n location ~ \\.php$ {\n    include snippets/fastcgi-php.conf;\n\n    fastcgi_pass 127.0.0.1:9000;\n  }\n\n啟用上述設定，重開 nginx，並查看 nginx 是否正常運作\nsudo service nginx restart\nsudo systemctl status nginx\n編輯 info.php 檔案\nsudo vim /var/www/html/info.php\n複製貼上以下程式碼\n&lt;?php phpinfo();\n瀏覽 http://192.168.56.10/info.php ，應該會看到 PHP Version 8.3 相關設定\n刪除 info.php 檔案\nsudo rm /var/www/html/info.php\nnode.js\nsudo apt install -y curl build-essential\ncurl -sL deb.nodesource.com/setup_20.x | sudo bash -\nsudo apt install -y nodejs\n \nnode -v\nnpm -v\nyarn\nsudo npm install --global yarn\nyarn --version\n安裝 composer\n複製貼上官網的指令\ngetcomposer.org/download/\n移到系統資料夾，並檢查是否可以全域呼叫\nsudo mv composer.phar /usr/local/bin/composer\ncomposer --version\n安裝 laravel\nsudo apt install -y zip unzip php$PHP_VERSION-{zip,xml,bcmath}\ncomposer global require &quot;laravel/installer&quot;\n \necho &#039;export PATH=~/.local/bin:~/.config/composer/vendor/bin:$PATH&#039; &gt;&gt; ~/.bash_profile\nsource ~/.bash_profile\n建立 Laravel 10 專案\ncd ~/apps\n \n# 安裝最新版本，project_name 改成想要的目錄名稱\nlaravel new project_name\n# 或者安裝指定版本 (10)，project_name 改成想要的目錄名稱\ncomposer create-project laravel/laravel=10.* project_name --prefer-dist\n \ncd project_name\n \n# 安裝相依的 PHP 套件\ncomposer install\n \n# 安裝前端編譯需要的套件\nyarn install\n之前執行 yarn dev 遇到問題，產生錯誤訊息\n\nError: ENOSPC: System limit for number of file watchers reached\n\n解決方法是修改 sysctl.conf 的設定\necho fs.inotify.max_user_watches=524288 | sudo tee -a /etc/sysctl.conf &amp;&amp; sudo sysctl -p\n# 應該顯示 524288\ncat /proc/sys/fs/inotify/max_user_watches\n上述方法來自於 React Native Error: ENOSPC: System limit for number of file watchers reached\n執行前端編譯與監視檔案變動\n# 按 q 離開\nyarn dev\n設定 nginx 執行 Laravel\nsudo vim /etc/nginx/nginx.conf\n# 修改第一行 user www-data; 為 user tom;\n假設專案名稱是 project_name\nsudo vim /etc/nginx/sites-available/project_name.conf\n複製貼上以下設定。注意 root 要改成 Laravel 專案的絕對路徑，listen 8111 表示設定 port 是 8111\nserver {\n  listen 8111;\n  server_name 192.168.56.10;\n  index index.php index.html;\n  client_max_body_size 50M;\n  root /home/tom/apps/project_name/public;\n  location / {\n    try_files $uri $uri/ /index.php$is_args$args;\n  }\n  location ~ \\.php$ {\n    try_files $uri = 404;\n    fastcgi_split_path_info ^(.+\\.php)(/.+)$;\n    include fastcgi_params;\n    fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;\n    fastcgi_param SCRIPT_NAME $fastcgi_script_name;\n    fastcgi_index index.php;\n    fastcgi_pass 127.0.0.1:9000;\n  }\n}\n\n啟用設定，並重新啟動 nginx\nsudo ln -s /etc/nginx/sites-available/project_name.conf \\\n           /etc/nginx/sites-enabled/project_name.conf\nsudo systemctl restart nginx\n瀏覽 http://192.168.56.10:8111\n安裝 MariaDB\nsudo apt install -y mariadb-server php$PHP_VERSION-mysql\nsudo mariadb-secure-installation\n接下來會回答一系列問題，下一行則是建議操作\nEnter current password for root (enter for none):\n按下 enter\nSwitch to unix_socket authentication [Y/n]\n按下 enter\nChange the root password? [Y/n] \n按下 n\nRemove anonymous users? [Y/n]\n按下 enter\nDisallow root login remotely? [Y/n]\n按下 enter\nRemove test database and access to it? [Y/n]\n按下 enter\nReload privilege tables now? [Y/n]\n按下 enter\n新增資料庫\nsudo mariadb\n執行以下 SQL 新增使用者 project_name 和資料庫 project_name(或換成想要的名稱)。記得密碼要修改（IDENTIFIED BY &#039;密碼&#039;）\nCREATE DATABASE project_name CHARACTER SET utf8mb4;\nCREATE USER &#039;project_name&#039;@&#039;localhost&#039; IDENTIFIED BY &#039;密碼&#039;;\nGRANT ALL PRIVILEGES ON project_name.* TO &#039;project_name&#039;@&#039;localhost&#039;;\nFLUSH PRIVILEGES;\nexit\n用編輯器打開 .env 檔案，修改以下設定。DB_DATABASE、DB_USERNAME 和密碼要改成剛剛設定的\nDB_CONNECTION=mysql\nDB_HOST=127.0.0.1\nDB_PORT=3306\nDB_DATABASE=project_name\nDB_USERNAME=project_name\nDB_PASSWORD=&#039;密碼&#039;\n\n執行 migration 測試設定是否正確\nphp artisan migrate"},"常用-Vim-指令清單":{"slug":"常用-Vim-指令清單","filePath":"常用 Vim 指令清單.md","title":"常用 Vim 指令清單","links":[],"tags":[],"content":"以下為「Vim 實用技巧」的筆記。Vim 指令實在很多，所以寫份清單方便查詢\n標示說明\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n標示說明&lt;C-A&gt;Ctrl + A&lt;S-A&gt;Shift + A&lt;CR&gt;Return 或 Enter&lt;BS&gt;Backspace &lt;--\noperator 運算子\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\noperator 運算子或指令說明x刪除一個字元d / D刪除或剪下。d 後面接 motion，D 則是直到改行結尾y 或 Y複製。y 後面接 motion，Y 則是直到改行結尾p / P貼上：游標在貼上的文字第一行非空白字元開頭gp / gP貼上：游標在貼上的文字最後一行開頭 / 留在原來那一行的開頭:set paste貼上時取消縮排&gt; / &gt;&gt; / &lt; / &lt;&lt;向右縮排 / 向右縮排一行 / 向左縮排 / 向左縮排一行= / ==自動縮排 / 自動縮排一行&lt;C-A&gt; / &lt;C-X&gt;數字遞增 / 遞減gu / gU / g~英文字母 轉小寫 / 轉大寫 / 切換大小寫 (後面要加 motion)~切換大小 寫(visual mode) u / U / ~英文字母 轉小寫 / 轉大寫 / 切換大小寫點 .重複上次修改（外掛 vim-repeat 透過 點 . 重複外掛操作）u取消上次修改&lt;C-R&gt;重作被取消的修改\nmotion 動作\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmotion 動作說明Practical Vim 頁碼小寫 L游標所在的一個字元h / j / k / l(實際行) 移動游標 左 / 下 / 上 / 右gh / gj / gk / gl(螢幕行) 移動游標 左 / 下 / 上 / 右w / b / W / B游標在單字開頭 下一個英文單字 / 上一個英文單字 / 下一個字串 / 上一個字串107e / ge / E / gE游標在單字結尾 下一個英文單字 / 上一個英文單字 / 下一個字串 / 上一個字串107數字 0 / ^ / $(實際行) 此行 開頭 / 開頭(非空格) / 結尾g數字 0 / g^ / g$(螢幕行) 此行 開頭 / 開頭(非空格) / 結尾f 字元 / F 字元 / t 字元 / T 字元(尋找此行游標的) 右邊 字元 / 左邊 字元 / 右邊 字元 的左邊 / 左邊 字元 的右邊分號 ; / 逗號 ,(尋找此行) 下一個 / 上一個gg / G緩衝區 第一行 / 最後一行%成對括號的結尾或開頭122“ (連續兩個鍵盤上方 ~ 下方的 ` )回到上一個跳轉的游標位置：是指 %、gg 或 G、`a 、0 或 $、或搜尋之類的跳轉，所以上下左右移動不算，用 w 或 b 跳轉也不算\ntext object 文字物件\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntext object 文字物件說明Practical Vim 頁碼iw / iW / aw / aWinside word / inside 字串 / a word / a 字串i) / i] / i} / i&gt; / i&#039; / i&quot; / i\\ / itinside 括號、引號、html tag (不包含括號、引號、html tag 本身)117a) / a] / a} / a&gt; / a&#039; / a&quot; / a\\ / at一個括號、引號、html tag (包含括號、引號、html tag 本身)117is / as文章的一個句子，以一個點 . 表示到此為一句，中文也是 (注意，不是一行)119ip / apa paragraph (文章的一個段落)119targets.vim 提供許多額外的 text object\nregister 暫存器\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n存取暫存器指令例如貼上複製好的字串(normal mode) &quot;{register}(normal mode) &quot;0(insert mode) &lt;C-R&gt;{register}(insert mode) Ctrl + R 數字 0(Ex mode) &lt;C-R&gt;{register}(Ex mode) Ctrl + R 數字 0指令說明(Ex mode) @{register}執行暫存器內容:reg a / :reg顯示 register a 的值 / 顯示所有 register 的值暫存器代表符號 {register}說明=expression 暫存器 (貼上簡單的數學計算結果，例如 (normal mode) &quot;=2+3 會貼上 5)&quot;無名暫存器{a-z}有名暫存器，從 a 到 z0複製專用暫存器{1-9}delete 專用暫存器。1 是最近的，可紀錄到前9個%目前檔案名稱#輪流切換的檔案名稱 (使用 :bn 等命令時，上一個檔案的名稱).上次插入的文字:上次執行的 Ex 命令/上次搜尋的 pattern_黑洞暫存器 (刪除而且不留副本)\nfolding 折疊\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n指令說明:set foldmethod=摺疊方式foldmethod 可縮寫成 fdm:set fdm=manual手動摺疊:set fdm=indent依照縮排摺疊:set fdm=syntax依照語法摺疊(似乎要另外設定一些東西才能運作)zf{motion}手動新增摺疊，例如 zf3j 摺疊目前游標到下面三行用 visual mode 選好範圍，按 zf選取範圍手動新增摺疊:[range] foldex 命令手動新增摺疊，例如 :10, 25 fold 摺疊 10 到 25 行zd /zE刪除游標所在摺疊 / 刪除所有摺疊zo打開游標所在摺疊zc關閉游標所在摺疊zx打開游標所在摺疊，其餘關閉za切換游標所在摺疊zi切換啓用摺疊zj / zk移動到下一個摺疊 / 上一個摺疊zn / zN啓用摺疊 / 禁用摺疊\n自動補齊\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n指令說明Practical Vim 頁碼(insert mode) &lt;C-N&gt;普通關鍵字 (包含目前緩衝區、引入檔案和 ctags)265(insert mode) &lt;C-X&gt;&lt;C-N&gt; / &lt;C-X&gt;&lt;C-P&gt;目前緩衝區關鍵字：下一個 / 上一個(insert mode) &lt;C-X&gt;&lt;C-I&gt;include, import 等引入的檔案關鍵字(insert mode) &lt;C-X&gt;&lt;C-]&gt;ctags 標籤檔案關鍵字(insert mode) &lt;C-X&gt;&lt;C-K&gt;拼字建議 (先啟用拼字檢查)(insert mode) &lt;C-X&gt;&lt;C-L&gt;目前緩衝區整行補齊(insert mode) &lt;C-X&gt;&lt;C-F&gt;檔案名稱補齊 (依照目前工作目錄)(insert mode) &lt;C-X&gt;&lt;C-O&gt;Omni 全能補齊(需要額外設定)(關鍵字清單) &lt;C-N&gt; / &lt;C-P&gt;填上選擇的關鍵字：下一個 / 上一個266(關鍵字清單) &lt;Down&gt; / &lt;Up&gt; / &lt;C-Y&gt;選擇關鍵字：下一個 / 上一個 / 確認填上選擇的關鍵字(關鍵字清單) &lt;C-E&gt;取消自動補齊(關鍵字清單) &lt;C-H&gt; 或 &lt;BS&gt;填上關鍵字並刪除一個字元輸入任意字元中止自動補齊並插入字元\n插入字元符號\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n插入字元符號說明以下的 i, a, s, c, r 和 o 都是進入 Insert modei / 大寫 I游標前面 / 游標所在該行的非空白開頭a / 大寫 A游標後面 / 游標所在該行的結尾s / 大寫 S刪除游標所在的字元後 / 刪除游標所在該行所有非字元後c{motion} / 大寫 C刪除指定 motion 字元後 / 刪除游標到該行結尾後r / 大寫 R修改一個字元後 / 進入 replace mode，直到按下 &lt;ESC&gt; 或 &lt;C-[&gt;，回到 normal mode英文字母 o / O新增一行後：下面 / 上面(insert mode) &lt;C-H&gt;刪除前一個字元 (等同 backspace)(insert mode) &lt;C-W&gt;刪除前一個單字(insert mode) &lt;C-U&gt;刪除到此行開頭(非空格)&lt;ESC&gt;切換到 normal mode(insert mode) &lt;C-[&gt;切換到 normal mode(insert mode) &lt;C-O&gt;切換到 insert-normal mode (執行一個 normal mode 指令後回到 insert mode)(insert mode) &lt;C-V&gt;準備插入特殊字元&lt;C-V&gt;{065}插入編碼為 000 到 999 的 ANSI Code 字元，&lt;C-V&gt;065 會輸入 A&lt;C-V&gt;u{1234}插入編碼為 16 進位 0000 到 ffff 的 Unicode 字元&lt;C-V&gt;非數字插入原來的字元:h i_CTRL-V_digit上述功能的簡短說明(insert mode) &lt;C-K&gt;準備插入 digraph 二合字母&lt;C-K&gt;{字元}{字元}例如 &lt;C-K&gt;12 插入數學的二分之一:h digraph-table二合字母列表:h digraph-table-mbyte二合字母列表(包含日文假名和注音符號)\n拼字檢查\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n指令說明:set spell / :set nospell / :set spell!拼字檢查：啟用 / 停用 / 切換]s / [s跳轉到拼寫錯誤的單字：下一個 / 上一個數字z=顯示更正建議清單，可在前面加上數字，直接選取清單的第幾個單字zg / zw / zug增減建議字典檔：增加 / 刪除 / 取消之前的 zg 或 zw 命令\nvisual 模式\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n指令說明v / V / &lt;C-V&gt;使用 visual mode：字元 / 此行 / block 區塊gv重新選擇上次的 highlight 選擇區(visual mode) 英文字母 o切換 highlight 選擇區的調整端\nex mode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n指令說明:選擇範圍 命令 {到達位置}先選擇範圍，再輸入命令(如果沒有選擇範圍，預設為目前這一行)選擇範圍:n移動游標到第 n 行:m, n第 m 行到第 n 行，游標停在第 n 行:1, $從第一行到最後一行:1, .從第一行到游標所在這一行（數字 1 到一個點）數字 0目前檔案第一行的上一行 (用 :put 貼到第一行時需要用到):%整個檔案 (參考 :h cmdline-special 和 :h filename-modifiers)使用 visual mode 之後按 :目前的 visual mode highlight 範圍:&#039;&lt;, &#039;&gt;上一次的 visual mode highlight 範圍(開始和結束):/pattern1/, /pattern2/從 pattern1 這一行到 pattern2 那一行:/pattern1/+m, /pattern2/-n從 pattern1 這一行往下 m 行到 pattern2 那一行向上 n 行 (注意加和減兩邊沒有空格)ex 命令:print 或 :p顯示:copy 或 :co / :t (copy To)複製(不會放到預設的暫存器中):move 或 :m移動:delete 或 :d刪除:[line]put {register}貼上到指定行的下一行:normal @{a-z}執行 normal mode 命令，@{a-z} 表示執行的是 macro@:重複之前的 ex 命令@@重複之前用 @: 執行過的 ex 命令q:顯示 ex 命令歷史視窗。按下 enter 表示執行游標所在那一行的 ex 命令q/顯示搜尋歷史視窗(ex mode) &lt;C-F&gt;從 ex mode 切換到 ex 命令歷史視窗(ex mode) &lt;C-D&gt;顯示可用的 ex 命令(ex mode) &lt;TAB&gt;自動補齊(ex mode) &lt;S-TAB&gt;從最後一個開始，自動補齊(ex mode) &lt;C-R&gt;&lt;C-W&gt;複製游標所在的單字(ex mode) &lt;C-R&gt;&lt;C-A&gt;複製游標所在的字串(直到兩邊的空格):shell / exit切換到互動式 shell / 切換回 Vim&lt;C-Z&gt; / fg暫停 Vim ，並移到背景 / 把 Vim 移回前景:read !cmd執行 shell 指令(cmd)，並把輸出貼到 Vim 游標所在下一行。read 可以縮寫為 r:[range]write !cmd把 Vim 選取範圍傳給 shell 指令(cmd) 做為其參數。write 可以縮寫為 w:[range] !{filter}使用外部 shell 指令過濾指令範圍:source file.vim套用 file.vim 內的 ex 命令(ex mode) cmd | cmd分隔兩個 cmd 命令\n管理多個檔案\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n指令說明Practical Vim 頁碼:q!指令後面加上驚嘆號表示強制執行，不確認打開檔案:edit / :edit! / :e打開檔案 / 重新打開檔案，覆蓋目前的緩衝區 / :edit 的縮寫:find file在 path 中尋找檔案 file 並打開 (這樣就不用完整路徑了)91:set path+=app/**新增 path 為 app/ 和子目錄91:edit . 或 :e. / :E[xplore]打開 Netrw 文件管理器： 目前檔案所在目錄 / 目前工作目錄94:lcd / :cd設定 working dictionary：目前視窗 / 所有的視窗:pwd顯示目前視窗的 working dictionary (不是檔案位置)存檔:w[rite] / :wa[ll]存檔 / 全部存檔:write fileVim 存檔為 file。write 可以縮寫成 w:update存檔 (有修改的才儲存):q[uit] / :q! / :qa[ll]!離開 Vim / 不存檔 / 全部不存檔緩衝區:ls顯示緩衝區清單:bn[ext] / :bp[revious] / :bfirst / :blast切換緩衝區 下一個 / 上一個 / 第一個 / 最後一個&lt;C-^&gt;切換到上一個顯示的緩衝區。酸然是 ^，但是不用按 &lt;S&gt; 所以實際上是 &lt;C-6&gt;:b[uffer] 數字或名稱切換到 !ls 清單的指定緩衝區。可用&lt;TAB&gt;自動補齊:[range] bd[elete] / :bd[elete] 1 2 3刪除緩衝區 指定範圍 / 指定哪幾個args 命令:args file1 file2開啟指定檔案，緩衝區順序依照輸入順序:args */*.* / :args **/*.*開啟檔案 不包含子目錄的檔案 / 包含子目錄內的檔案79:args `shell cmd`執行反引號  ` 包起來的 shell 指令，把輸出作為要開啟的檔案。沒有檔案的話就新增檔案79&lt;C-G&gt;顯示目前檔案名稱和狀態\n分割視窗 / Tab 分頁\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n指令說明Practical Vim 頁碼分割視窗&lt;C-W&gt;s / &lt;C-W&gt;v分割視窗：水平 / 垂直83:sp[lit] file / :vsp[lit] file分割視窗，並在新視窗中打開檔案：水平 / 垂直84&lt;C-W&gt; 加上 w / h / j / k / l切換視窗：循環 / 左 / 下 / 上 / 右84:clo[se] / &lt;C-W&gt;c關閉 active window84:on[ly] / &lt;C-W&gt;o關閉其他視窗84:windo 命令目前 Tab 的所有視窗，執行命令86Tab 分頁:tabe[dit] file / &lt;C-W&gt;t開新的 Tab，打開檔案。沒有檔案的話，開新的檔案 / 移動目前視窗到新的 Tab87:tabc[lose] / :tabo[nly]關閉目前 Tab / 關閉其他 Tab87:tabn[ext] n / :tabp[revious]切換 Tab：跳到編號 n 的，不指定編號則為下一個 / 上一個87編號gt / gT切換 Tab：跳到指定編號的 Tab，不指定編號則為下一個 / 上一個87:tabm[ove] 數字移動 Tab 順序，數字 0 表示最左邊，然後是 1 。沒有數字則為最右邊\n跳轉\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n指令說明Practical Vim 頁碼:jumps / &lt;C-O&gt; / &lt;C-I&gt;跳轉：顯示歷史清單 / 上一個位置 / 下一個位置 (注意：只能用來跳轉，而且只能在目前的視窗中跳轉)125, 126m{a-z} / m{A-Z}標示目前游標位置：小寫字母(目前顯示的緩衝區內可用) / 大寫字母 (所有緩衝區可用)120`{字母}跳到位置標記：第幾行和第幾列121&#039;{字母}跳到位置標記：第幾行的開頭gf跳轉到目前游標下的檔案。用在 include(&#039;file&#039;) 之類128, 129, 130:set suffixesadd+=.php,..html,.htm,.js,.css指定 gf 時要嘗試加上的副檔名&lt;C-]&gt; / g&lt;C-]&gt; / &lt;C-T&gt;跳轉到定義 / 跳轉到定義，並且顯示清單 / 回到原處242:tselect / :tnext / :tprev顯示 ctags 清單243\n搜尋\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n指令說明Practical Vim 頁碼/{pattern}/[e]向下搜尋：沒有 {pattern} 則使用上一個 {pattern}，e flag 表示游標在匹配的結尾193?{pattern}/[e]向上搜尋：沒有 {pattern} 則使用上一個 {pattern}，e flag 表示游標在匹配的結尾193n / N下一個匹配 / 上一個匹配gn / gN進入 visual mode，同時選取匹配：下一個匹配 / 上一個匹配 (此為 motion)195, 196搜尋單引號內的文字197, 198, 199搜尋 visual mode 選取的文字202, 203\n取代\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n指令說明Practical Vim 頁碼:[range]s[ubsititute]/{before}/{after}/[gcn]取代文字：搜尋 before，改成 after205:%s//{pattern}/g使用上一個搜尋條件取代為 {pattern} (常用的取代命令格式)209flag g / c / n全部取代 / 確認後取代 / 不取代，只計算符合的數量flag c 的選擇208:&amp;&amp;執行上一個 substitute 取代命令和上一個 flag215\nmacro 巨集\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n指令說明Practical Vim 頁碼q{a-z} / q錄製 macro / 停止錄製 macro數字@{a-z}執行 macro，可加上數字指定執行幾次 (出錯就會停止)(Ex mode) normal @{a-z}執行 macro (出錯不會停止)159@@執行上一個 macroq{A-Z}把命令加到舊的 macro 後面macro 只是存在 register 的文字，只要編輯後放回去，就能修改 macro170"},"從-Vim-到-Neovim":{"slug":"從-Vim-到-Neovim","filePath":"從 Vim 到 Neovim.md","title":"從 Vim 到 Neovim","links":[],"tags":[],"content":"Neovim 是從 Vim 分出去的版本，把 Vim 的程式碼複製後整理一番，並加上想要的新功能，類似兄弟鬧不合，到外面開分店，有各自的特色那樣。說來慚愧，我用 Vim 寫程式十幾年來都不知道怎麼它的正確發音，正巧 Neovim 官網首頁有內嵌一個 YouTube 影片介紹，有 Vi, Vim 和 Neovim 的正確發音。\n為什麼從 Vim 換成 Neovim？因為 flexoki 配色 很好看，而且沒有 Vim 版本。之前想要在 Vim 有語法自動補齊，以及安裝一些外掛時提到有 Neovim 這個程式。雖然 Neovim 有許多新功能，不過我都用不上。最近發現 Neovim 有 0.9.5 版本，已經有3、4 個月沒更新，看起來是穩定下來了，然後發現  flexoki 配色，安裝後一開始還不習慣，和原來 Vim 配色相比覺得不夠好，直到顯示 html\n\n對比原來 Vim 的配色更好看。\n\n也有可能是原來的配色幾年下來已經看膩了？\nNeovim 最好從 GitHub 上抓取最新版本安裝。如果用 apt-get 或 rpm 等套件管理安裝，還停留在 0.5 版，許多外掛要求至少 0.8 版。在 Ubuntu/Debian 安裝的指令如下\ncd /tmp\n# 瀏覽器連到 github.com/neovim/neovim/releases/latest 顯示最新版本\n# 抓取最新版本\nwget github.com/neovim/neovim/releases/download/v0.10.4/nvim-linux-x86_64.tar.gz\n# 解壓縮\ntar xzvf nvim-linux-x86_64.tar.gz\n# 複製所有檔案到 /opt\nsudo cp -r ./nvim-linux-x86_64/ /opt\n# 編輯 ~/.bash_profile，加上  export PATH=&quot;$PATH:/opt/nvim-linux-x86_64/bin&quot;\necho &#039;export PATH=&quot;$PATH:/opt/nvim-linux-x86_64/bin&quot;&#039; &gt;&gt; ~/.bash_profile\n# 輸入 nvi ，neovim 不套用外掛和設定\necho &#039;alias nvi=&quot;nvim -u NONE -N&quot;&#039; &gt;&gt; ~/.bash_profile\n# 重新讀取 ~/.bash_profile 以啟用設定\nsource ~/.bash_profile\n# root 也做一樣的設定，讓它可以用 neovim\nsu root\n# 加上  export PATH=&quot;$PATH:/opt/nvim-linux-x86_64/bin&quot;\necho &#039;export PATH=&quot;$PATH:/opt/nvim-linux-x86_64/bin&quot;&#039; &gt;&gt;  /root/.bash_profile\nsource /root/.bash_profile\nGuide to using Lua in Nvim說明如何轉移原來的 Vim 設定到 Neovim。例如 vim.o.number = true 顯示行數，設定放在 ~/.config/nvim/init.lua，改用 Lua 語言設定 Neovim，也可以沿用 Vimscript 語法，只要把 init.lua 改成 init.vim 即可，兩個只能選一個。\n安裝需要的 Nerd Fonts\n\n在 host 端，連到 Nerd Fonts ，搜尋 Symbols Only，點選 Symbols Nerd Font\n解壓縮後，滑鼠點兩下打開 SymbolsNerdFont-Regular.ttf 檔案，按右上方按鈕 install\n設定終端機使用這個字型\n\n下方狀態列設定 lualine.nvim 時突然覺得如果最右邊顯示時間到秒數，看著時間一分一秒的跳動，對於（工作時）把握時間寫程式應該會很有幫助，在 lualine.nvim  搜尋 datetime，找到以下的 Lua 程式碼\nsections = {\n  lualine_a = {\n    {\n      &#039;datetime&#039;,\n      -- options: default, us, uk, iso, or your own format string (&quot;%H:%M&quot;, etc..)\n      style = &#039;default&#039;\n    }\n  }\n}\n然後在狀態列設定 evil_lualine.lua 把上述的程式碼貼上去，最後調整時間格式。時間格式來自於\nvim-jp/vital.vim 第 325 到 362 行。後來找到下來兩個連結，也可以用\n\nrenenyffenegger.ch/notes/development/misc/strftime\nrenenyffenegger.ch/notes/development/vim/script/vimscript/functions/strftime\n\nVim 有個外掛 NerdTree，用來顯示類似 VS Code 左邊的檔案管理，Neovim 也有外掛Neo-tree、netrw.nvim 和 nvim-tree.lua  ，但是後來發現 Vim 內建的 Netrw 已經夠用了，而且不會和外掛 BufSelect 衝突（Neo-tree 會和 BufSelect 衝到，無法使用）。\nBufSelect buffer 管理工具。之前 Vim 有和 VS Code 一樣的檔案分頁，分頁一多，螢幕很快就不夠寬了，而且會一直按 ]b 切換 buffer，明明能用 :b 數字 會更快。後來覺得用 :ls 會更好，尤其用空白鍵(SPACE) 呼叫 :ls ，應該比分頁一直擺在那裡佔著螢幕空間更好。之前用 Vim 就已經找到一個外掛，但是這個更好，至少好看多了。\nnvim-autopairs 自動加上右括號，確保括號成對。之前 Vim 試了幾個才找到合適的，Neovim 倒是第一個就很好用\nVim 有安裝外掛，自動顯示多餘的空格，並且能一個指令快速清除。到了 Neovim  時代，Highlight Whitespace 只有顯示多餘的空格和空行，無法用指令一次清掉。不過它有把 markdown 用不同顏色顯示，因為 markdown 段落和結尾加上兩個空格代表強制換行，有其作用，應該用溫和的顏色標示。trim.nvim 比起 Vim 時代的外掛只能清除多餘的空格，這個外掛還加上刪除多餘的空行，並且把 markdown 設成例外\nVim 有安裝外掛 vim-visual-star-search ，Visual 模式選取後以此搜尋 ，Neovim 似乎不需要外掛就能辦到？即使選取的文字包含 @ 也行\n外掛 unimpaired.vim 功能是各種成對操作，例如 [b 和 ]b 是上一個開啟的檔案(buffer)和下一個檔案，[空格 和 ]空格 是游標上面新增一行和下面新增一行。多年來其實只用到切換 buffer 和新增一行，就不裝外掛了，直接用 remap 設定就好，不然其實有找到外掛\n左邊的 navigate marks highlight 顯示有用外掛 vim-signature ，Neovim 也有外掛marks.nvim\n總結\n搬到 Neovim 後，省略許多之前的 vim 設定，同時丟掉許多實際上沒用到的外掛，當初只是為了漂亮的配色，但是成果比我想像的更好。Neovim 設定放在 tomleesm/nvim，最後附上一張截圖\n"},"怎麽學-Vim-？":{"slug":"怎麽學-Vim-？","filePath":"怎麽學 Vim ？.md","title":"怎麽學 Vim ？","links":[],"tags":[],"content":"在終端機(Windows 則為命令提示字元)執行指令 vimtutor，會顯示 Vim 內建的入門指南 Vim Tutor，完成全部練習，你就會基本操作。如果想看中文版本，則執行指令 vimtutor zh\n如果 Vim 的高門檻仍然沒有嚇跑你，那接下來呢？想全面掌握 Vim，我推薦 Practical Vim 這本書，當初我是看簡體中文版本，書名是「Vim 實用技巧」。副標題「Edit Text at the Speed of Thought」（以思維的速度來編輯文本）是指使用 Vim 搭配盲打，則想到哪裡文章就編輯到哪裡，不用等手指打完。書的前言最後說：\n\n先學會盲打，然後再學習 Vim…如果你要低頭看著鍵盤打字，那學習 Vim 的好處不會立竿見影呈現出來。要高效地使用 Vim，必須學會盲打\n\n其實不需要先學會盲打，我發現 Vim 可以幫助你熟悉盲打，我自己當初看這本書時仍低頭打字，現在用 Vim 做為主要編輯器，愈用愈久，盲打就愈來愈多。\n如同之前的故事說的，這本書會讓手指習慣用 Vim 的方式打鍵盤，無法改用其它編輯器。請小心，一腳踏入就回不去了。\n每個 Vim 重度使用者都有一大堆設定和外掛，常常用 GitHub 備份，我的在 github.com/tomleesm/vimrc 。外掛有一些刪節線，表示之前用了許多，最近則是發現其實 Vim 內建的就足夠了。"},"我為什麼想不開用-Vim-寫程式？":{"slug":"我為什麼想不開用-Vim-寫程式？","filePath":"我為什麼想不開用 Vim 寫程式？.md","title":"我為什麼想不開用 Vim 寫程式？","links":[],"tags":[],"content":"2001 年大學的 C 語言課程，老師要我們在實習課登入 Sun 主機，用 Vi 寫程式。雖然後來許多同學改用 nano ，但我還是堅持用 Vi，明明自己也覺得很難用，也許是高中時有很厲害的同學說他用 vim 寫程式，所以認為用 Vi 很酷吧。\n也就只有 C 語言課程用 Vi，之後就沒有用了。幾年後開始工作，用 PHP 寫網站，我用 Windows 版本的 gvim，後來開始用 markdown 語法寫東西，而 Atom 內建 markdown 預覽功能，所以寫程式也改用 Atom，就這樣又過了幾年。\n至此我的 Vim 技能僅停在相當粗淺的認識，只知道在 normal 模式用 :q 離開 Vim，:q! 不存檔離開 Vim，用 i、a、I 或 A 進入 insert 模式開始輸入，用 :w 存檔，以及一些設定選項。有一天好奇 Windows 程式集中 Vim 有哪些功能，就一個個用滑鼠點開來，意外打開 Vim Tutor（Vim 內建的教學文件），雖然跟著操作一遍，但我對 Vim 的操作仍停留在本段開頭的那些指令，沒有多大進步。\n塞翁失馬，焉知非福。我的 MacBook Air 更新作業系統時，操作不慎，SSD 格式化了，又不想花錢去店裡重灌 OS X（要800元），想到之前看過 Ubuntu 14.04 有 Mac 版本，就想辦法裝上去。後來為了用 Laravel 6 寫程式，所以用 VirtualBox 新增虛擬機器，跑 Debian。\n這時候遇到一個大問題：如果仍用 Atom 寫 PHP，首先 Atom 在當時的 Ubuntu 14.04 跑不動，程式直接當掉，改用 VS Code 也一樣，只能用 vim 或 gvim；另外需要用 rsync 不停同步 host 和 guest，導致 CPU 飆到 100%，筆電風扇不停地轉，Vagrant 也因為 Ubuntu 版本太舊無法安裝，實在不是辦法。改用其它編輯器嗎？之前趕流行還用過 TextMate 和 Sublime，上 Java 課用過 Eclipse ，一直換編輯器，我實在厭倦了，心想既然用 ssh 連進虛擬機器下指令，不如就在裡面用 Vim 寫程式好了，這樣就不用 rsync 同步程式碼，但是我的 Vim 技能實在很爛，怎麼辦呢？\n為了一勞永逸，以後都用 Vim 做為主要編輯器，不如找一本書好好學會 Vim，在天瓏書局找到 Practical Vim 的簡體中文版本「Vim 實用技巧」，一邊操作、一邊認真看完書。Vim 的功能之強讓我驚呆了，慢慢開始習慣用 Vim 寫程式，最可怕就是手指下意識按照 Vim 風格操作，於是在 VS Code 輸入完程式碼會按下 Esc 再輸入 :w 存檔，然後發現：「奇怪，為什麼打好的 code 裡有 :w 在結尾？」接著啊一聲、嘆氣，然後苦笑。「啊，已經回不去了」，於是回去用 Vim。\nUbuntu 14.04 for Mac 沒有新的版本，2022 年 10 月，我實在受不了一大堆程式不支援，連瀏覽器都一直警告我不再更新，於是 Google 「install Linux on Mac」，發現可以在 Mac 上安裝 x86 版本的 Linux，當天真的裝起來後，遙想當初如果先 Google 一下，不急著裝 Mac 版本的 Ubuntu ，會怎麼樣呢？\n現在筆電裝的是 Linux Mint 21 Xfce 版本，依然使用 Vim 寫程式，用 Obsidian 編輯 markdown 檔案寫部落格。為什麼不用 Vim 編輯 markdown？因為 Vim 已經有一堆模式要切換，再加上中文輸入法，實在太複雜了 。雖然有裝 VS Code ，但是不知道能拿它來做什麼。你說 VS Code 有 Vim 外掛，可是它缺少一堆功能，例如 :b 檔名 切換 buffer 和 :E 切換到檔案管理程式。後來聽說 Atom 和 Eclipse 有外掛可以連到伺服器上遠端編輯，用不著自己用 rsync 同步時，心痛了 3 秒。"},"時間管理方法":{"slug":"時間管理方法","filePath":"時間管理方法.md","title":"時間管理方法","links":[],"tags":[],"content":"一、記錄做了什麼和花了多少時間\n參考柳比歇夫時間管理法。我覺得他這個方法其實是在記錄心流時間，所以只記錄重要的工作耗費多久，沒有記錄吃飯、洗澡或午睡，雖然這些時間花費 8 小時（一天 24 小時減掉工作 6 小時和睡覺 10 小時，剩下 8 小時）。\n二、保持好奇心\n人類天生好奇，好奇心會引導你探索與學習一切，它是最強的動機。神奇的是，很快你會覺得 YouTube、臉書、新聞、Netflix 其實很無聊。內心深處真正想做的事情會浮現。"},"有興趣但是還沒研究的東西":{"slug":"有興趣但是還沒研究的東西","filePath":"有興趣但是還沒研究的東西.md","title":"有興趣但是還沒研究的東西","links":[],"tags":[],"content":"Zen Browser - 類似 Arc 瀏覽器，但是使用 Firefox Gecko engine 的開放原始碼瀏覽器\n\nblog.gslin.org/archives/2024/08/28/11951/%e6%b8%ac%e8%a9%a6-zen-browser/\nZen Browser使用心得，界面漂亮沉著、靜默提昇生產力的瀏覽器\ndocs.zen-browser.app/benchmarks Speedometer 3.0 出現的 Librewolf 似乎更好？\n\n糾結了很久 Chrome 和 Arc，最終選擇了 Librewolf\nLibrewolf 是一款基於 Mozilla Firefox 開發的瀏覽器。Firefox 本身是一款很優秀的開放原始碼軟體，其優點可見下圖。\nLibrewolf 則在此基礎上增加了一些高級的隱私保護設定，方便普通使用者使用\n最終，選擇從 Chrome 換成 Libreworf 有以下幾個原因：\n\n常用的 Chrome 外掛都能在 Librewolf（Firefox 外掛商店） 上找到，使用體驗與過去一致。Arc 的標籤頁邏輯我一直不習慣；\n我的 Chrome 瀏覽器一直有奇怪的 Bug：在第三方平台登錄Google帳號偶爾會登錄不進去報錯，Safari 則可以；\nArc 的側邊欄體驗很好，而 Sidebery 能實現類似的功能，並提供樹狀的標籤頁結構，設定請參考：組態 Firefox 垂直標籤欄。設定完成後介面很乾淨（見下圖）；\nFirefox 核心的瀏覽器能耗更低。這是個奇怪的需求，但確實需要。我出差的時會攜帶一款 65w 的充電器，軟體開的比較多的時候，會出現充不進電的情況；\n本想選擇 Firefox （小狐狸太可愛了），但 Libreworf 的隱私設定開箱即用，實在方便。如果使用 Firefox，日後我可能還會想再折騰一次；\n新鮮感；\n隱私很重要：Why Do I Care So Much About Privacy?；\nLibrewolf 默認不播放任何 DRM 內容。YouTube 沒有對創作者的視訊進行 DRM 保護，但卻對他們的商業廣告進行了 DRM 保護。因此，使用 Librewolf 可以完全免費地享受無廣告的 YouTube 視訊體驗；\n開放原始碼軟體很酷。如果兩款軟體提供相似的體驗，我會選擇開放原始碼的那個。\n\nFirefox 外掛\nLibreworf 使用的是 Firefox 外掛商店。\n\nBypass Paywalls Clean，用於繞過付費網站的付費牆，訪問受限制的內容。\nChatGPTBox，總結網頁內容。\nClearURLs，隱私工具，可以自動刪除 URL 中的跟蹤參數和不必要的中繼資料。\nClip to DEVONthink，將 Web 頁面上的內容剪下並保存到 DEVONthink。\nContent Farm Terminator，識別內容農場網站，這些網站通常以低品質的內容和廣告為主。\nCopy PlainText，從網頁中複製純文字。\nDualsub，在視訊中顯示兩種語言的字幕。\nEasyScholar，顯示科研論文的影響因子和分區。\nEnhanced GitHub，最佳化 GitHub 瀏覽和使用體驗。\nEnpass Password Manager，密碼管理器。\nGoogle Scholar Button，快速訪問 Google 學術搜尋引擎。\nHumble New Tab Page，自訂新標籤頁。\nI don’t care about cookies，停用網站的 cookie 通知，以提高瀏覽體驗。\nImmersive Translate: Web Page&amp;PDF Translation，用於網頁和 PDF 翻譯的外掛。\nMetaMask，加密貨幣錢包外掛。\nReadwise Highlighter，將文章匯入 Readwise Reader，並高亮和批註。\nSidebery，樹狀結構的瀏覽器標籤頁側邊欄，設定請參考：組態 Firefox 垂直標籤欄。\nTampermonkey，指令碼管理器，自訂網站的行為和外觀。我使用的指令碼如下圖所示，已備份上傳到 Github。\nUBlock Origin，廣告遮蔽軟體。\nV2EX Polish，最佳化 v2ex 瀏覽體驗。\nZotero Connector，Zotero 文獻管理軟體的瀏覽器外掛，收集、管理和引用學術文獻和資訊。\nSearX，更改了默認搜尋引擎。\n\nNgrok 的開源替代方案 frp\n\n實戰frp內網穿透　內部主機也能對外服務\nfatedier/frp\n在 AWS 上使用 EC2 建立 FRP 玩玩內網穿透\nFrpc-Desktop frp 的跨平台 GUI 客户端\n\nwruby 僅有一個 ruby 檔案的靜態部落格程式\n\n建立的 blog 是這個 btxx.org/\ngit.sr.ht/~bt/wruby\nsummary 是說明((README.md)，原始碼在 tree\n\n用 PostgreSQL 取代 MongoDB\n\nMangoDB：拿 PostgreSQL 當作後端的 MongoDB 相容層\nMangoDB 改名為 FerretDB (雪貂)\n直接在 library 層將 MongoDB 用法轉換成 PostgreSQL 底層的 Pongo\n\n不用 .env 改用 vault service\ndotenvx\n\n…這十年下來已經知道把 secret 放在環境變數裡太容易洩漏…\n目前被提出來比較好的方法是把 secret 都放到 vault service 裡面，由 vault service 給一把讀取用的 API key，放進 dotenv 或是其他地方 (被稱為 secret zero)。\n這樣這把 API key 去 vault service 抓取真正的 secret 放到程式內的物件取用 (像是資料庫的帳號密碼)，而不是環境變數。\n\nvault service 解決方案：\n\nHashiCorp Vault 文件 原始碼\netcd (然後搭配 etcd-adminer 以及 oauth2-proxy 接 Google Workspace 的 SSO 源自 gslin\nOpenBao 官網 原始碼\n\n想色色就去 Web3？\n成人內容平台審查嚴、銀行擋付款，OnlyFans明星投奔鏈上世界\n想色色就去 Web3？成人內容平台審查嚴、銀行擋付款，OnlyFans明星投奔鏈上世界\nPatreon 的創作者在提款時遭銀行誤判為詐騙，使他們遭受困擾:\nHey, if you’re a Patreon creator and are confused as to why a bunch of your income vanished, it’s because Patreon’s system appears to have totally collapsed. They sent me an email saying my credit card blocked the payment as fraudulent, and CANCELLED ALL OF MY CREATOR SUPPORT.\n\ntwitter.com/JasonKPargin/status/1686783605551382530\n\nI told the credit card company the charge was valid, fine. Patreon sent an email saying “click here to update your payment” and that link goes to a 404 error. My list of supported creators is gone, I have to try to remember who I was supporting - there is nothing on the site\n\ntwitter.com/JasonKPargin/status/1686783937111015424\n\n2022 年，OnlyFans 模特 Allie Rae 推出了基於加密貨幣的成人內容平台 WetSpace，意在替代 OnlyFans。Rae 表示，創立此平台是為了避免銀行的干預，認為加密貨幣提供了一個很棒解決方案。\n近期，也有越來越多的 OnlyFans 創作者轉投基於 Layer2 Base 所建立的去中心化社交平台 Friend.tech。\nFriend.Tech用戶大量退出，Web3社交的友誼小船說翻就翻？\n\n所以雞蛋不要放在同一個籃子裡，要有備份帳號，作品要自己備份好 (AWS S3 Storage Class – Glacier Deep Archive、隨身硬碟)\n我如何將開源專案變成一項業務\ndocs.emailengine.app/how-i-turned-my-open-source-project-into/\n(以下是 Google 翻譯，下一個 comment 是英文原文)\n大約 15 年前，當我開始編寫和發布開源軟體時，我對此非常激進。我只使用像 MIT 或 BSD 這樣的寬鬆許可證，因為我只關心可及性。使用帶有附加條件的 Copyleft 許可證似乎阻礙了這一範圍。讓另一家 A 類公司使用我的開源程式庫（例如Nodemailer）是一種榮譽徽章。我甚至當一家主要交易電子郵件服務的創始人向我發送了一封有關 Nodemailer 的電子郵件並提出捐款以促進我的努力時，我拒絕了。我不想顯得受到主要提供者之一的影響，因為這對其他提供者不公平。\n事後看來，我真是個傻瓜。\n無論如何，幾年後，當一家使用 Nodemailer 的新創公司被以 5 億美元收購時，情況發生了變化。那時我的經濟狀況並不好，當我看到這個新聞時，我開始想──我從中得到了什麼？發送電子郵件通知是該服務的重要組成部分，他們可能每天使用 Nodemailer 發送數百萬封電子郵件通知。至少，我透過提供一個免費且可靠的庫來發送這些電子郵件，為他們節省了大量的開發時間。我在信箱中搜尋了與該公司相關的電子郵件，並發現了一封針對某項功能的投訴。沒有拉取請求，沒有捐贈，什麼都沒有。而且也沒有什麼好抱怨的，因為我故意將我的軟體提供給全世界使用，而不要求任何補償。我空空的錢包對事態的發展並不滿意。\n因此，當我開始最終成為 EmailEngine 時，我試圖盡可能地掩護自己。我在 Copyleft LGPL 授權下發布了該軟體。我還設定了一個自動化的 CLA 流程，讓任何人都無法在不先簽署 CLA 的情況下合併他們的 PR。許多人討厭 CLA，有幾個人首先創建了 PR，但在意識到存在 CLA 要求後就將其關閉。嗯，說實話，我並不太在意。例如，Nodemailer 98.1% 的程式碼是我自己寫的，只有 1.9% 來自其他貢獻者，因此 PR 合併不是什麼大問題。對於 EmailEngine，在開源發布一年半後，相同的數字分別為 99.8% 和 0.2%。\n\n我使用CLA 助理來管理專案中的 CLA (Contributor License Agreements)\n\n顯然，我想從我的新專案中賺點錢，而且我的商業計劃很簡單。我將該專案（當時稱為 IMAP API）作為 LGPL 許可的應用程式發布。我還提供了 MIT 版本，但要獲得該版本，您必須訂閱。訂閱費為每年 250 歐元。我的假設是，公司（該軟體的主要目標）不喜歡 Copyleft 許可證，一旦他們看到該應用程式有多有用，就會轉換為寬鬆許可證。\n好吧，事實證明我的商業計劃很瘋狂。我只獲得了一些付費訂閱者，而且在我看來，這些人甚至沒有使用 IMAP API。他們只是想支持我的努力。事實證明，小公司根本不關心許可證，而大公司也沒有使用它。經過一年半的總收入 750 歐元後，我決定跳槽——提供免費的東西已經足夠了。\n我重新設計了應用程式的使用者介面，使其看起來更專業，並實施了許可證密鑰系統。從那時起，如果您想使用 EmailEngine（IMAP API 的新名稱），您需要一個僅適用於付費訂閱者的許可證金鑰。我還將許可證從 LGPL 更改為商業授權。原始碼仍然在GitHub 上公開發布。根據定義，它不再是開源的，而是原始碼可用的。這種許可證變更之所以可能，是因為要求外部提交者從一開始就簽署 CLA。\n\n我仍然發布麻省理工學院許可的項目，但僅限於較小的工具，而不是較大的項目。這些工具的目標是促進我的主要努力。例如，我從 EmailEngine 中提取了 IMAP 用戶端函數，並在 MIT 授權下將其發佈為 Node.js 的通用 IMAP 用戶端程式庫。這個模組（ImapFlow）正在獲得越來越多的採用，因為它比任何現有的替代方案都要好得多。文件頁面每月向 EmailEngine 的主頁發送大約 100 名訪問者，雖然不多，但是嘿，這是免費流量，有時這些訪問者確實會發生轉化，使努力富有成果。\n起初，甚至沒有試用選項。如果您在應用程式啟動後 15 分鐘內未提供有效的許可證金鑰，則該應用程式將停止運作。\n\n我保持價格不變，每年 250 歐元，第一個月，我賣出了價值 1750 歐元的訂閱。這相當於我前一年半賺的錢的兩倍，它決定了這個專案的命運。沒有回頭路了。\n接下來，我開始提高定價；250 歐元變成了 495 歐元，然後是 695 歐元、795 歐元，最後是 895 歐元。令我驚訝的是，這並不意味著客戶數量減少。我想對企業來說任何低於 1000 美元的金額都是微不足道的，因此價格上漲唯一改變的是收入的增加。\n目前 EmailEngine 的 MRR (每月經常性收入)為 6100 歐元，並且穩定增長，在我居住的愛沙尼亞，這使我能夠支付自己一份體面的薪水，以便我可以全職從事我的專案。我唯一的遺憾是我沒有早點開始銷售我的軟體並且只發布免費的開源軟體。是的，我在 GitHub 上有一些贊助商，但金額從來都不是很大，每月 50-750 美元不等，具體取決於我碰巧有多少贊助商。向商業客戶銷售肯定比依賴隨機人員的善意更可靠和可預測。\nHow I turned my open-source project into a business\nWhen I started writing and publishing open-source software about 15 years ago, I was pretty radical about it. I only used permissive licenses like MIT or BSD, as all I cared about was reach. Using a copyleft license with strings attached seemed to hinder that reach. Getting another A-category company to use my open-source libraries like Nodemailer was a badge of honor. I even went so far that when a founder of a major transactional email service sent me an email regarding Nodemailer and offered to make a donation to promote my efforts, I rejected it. I did not want to seem affected by one of the dominant providers because this would not be fair to other providers.\nIn hindsight, what a fool I was.\nIn any case, it changed years later when a startup using Nodemailer was acquired for half a billion dollars. I was financially not in a good place back then, and when I saw the news, I started to wonder – what did I get out of this? Sending email notifications was a huge part of that service, and they probably sent millions of email notifications a day using Nodemailer. At the very least, I saved them tons of developer hours by providing a free and solid library for sending these emails. I searched my mailbox for emails related to that company and found a single complaint about a feature. No pull requests, no donations, no nothing. And there was nowhere to complain either as I had knowingly given my software for the world to use with no requirements to compensate anything. My empty wallet was not happy about the turn of events.\nSo, when I started what eventually became EmailEngine, I tried to cover my back as much as possible. I released the software under the copyleft LGPL license. I also set up an automated CLA process so that no one was able to get their PR merged without signing a CLA first. Many people hate CLAs, and several persons opened a PR first but closed it once they realized that there was a CLA requirement. Well, to be honest, I didn’t really care. For example, 98.1% of the code for Nodemailer was written by myself, and only 1.9% was from other contributors, so not getting PRs merged was not a major issue. For EmailEngine, after a year and a half of being published as open source, the same numbers were 99.8% vs 0.2%.\nI use CLA assistant for managing CLAs in my projects\nObviously, I wanted to make some money from my new project, and my business plan was simple. I published the project (it was called IMAP API at that time) as an LGPL-licensed application. I also offered an MIT version, but to get that, you had to subscribe. The subscription fee was 250€ per year. My assumption was that companies - the main target for the software - do not like copyleft licenses and would convert to the permissive license once they see how useful the app is.\nWell, it turns out my business plan was bonkers. I only gained a few paying subscribers, and it seemed to me those people weren’t even using IMAP API. They just wanted to support my effort. It turned out that smaller companies did not care about the license at all, and larger companies were not using it. After a year and a half and 750€ in total revenue, I decided to jump ship — enough of providing free stuff.\nI re-designed the UI of the app to look more professional and implemented a license key system. From that moment if you wanted to use EmailEngine (the new name for IMAP API), you needed a license key that was only available for paying subscribers. I also changed the license from LGPL to a commercial license. The source code is still published publicly on GitHub. It is no longer open-source by definition but source-available. This change of license was only possible due to requiring outside committers to sign a CLA from the start.\nI still publish MIT-licensed projects, but only for smaller tools, not larger projects. The goal of these tools is to promote my main effort. For example, I extracted the IMAP client functions from EmailEngine and published it under an MIT license as a generic IMAP client library for Node.js. This module  (ImapFlow) is gaining steam in adoption as it is by far better than any pre-existing alternative. The documentation page sends about 100 visitors per month to EmailEngine’s homepage, which is not much, but hey, it is free traffic, and sometimes these visitors do convert, making the effort fruitful.\nAt first, there wasn’t even a trial option. If you did not provide a valid license key 15 minutes after the application started, the app just stopped working.\nI kept the price the same, 250€ per year, and during the first month, I sold 1750€ worth of subscriptions. That’s like twice the amount I made in the previous year and a half, and it sealed the fate of the project. There was no going back.\nNext, I started to increase the pricing; 250€ became 495€, then 695€ and 795€, and finally 895€. To my surprise, it did not mean getting fewer customers. I guess any sub-$1k amount for businesses is peanuts, so the only thing these price increases changed was improving the revenue.\nThe current MRR for EmailEngine is 6100€ and grows steadily, which in Estonia, where I live, allows me to pay myself a decent salary so that I can work on my project full-time. The only regret I have is that I did not start selling my software earlier and only published free, open-source software. Yes, I have some sponsors in GitHub, but it has never been a substantial amount, ranging from 50-750 per month, depending on how many sponsors I happen to have. Selling to business customers is definitely more reliable and predictable than depending on the goodwill of random people.\nHypervel 框架\nwww.facebook.com/groups/498481680220886\n今天和大家介紹 Hypervel 框架，起初是爲了在公司導入協程到高 I/O 情境的專案中，又希望能幫助同仁能以本來熟悉的 Laravel 框架快速熟悉開發而生，去年還在公司專案中進行內測，這幾個月漸漸將先前未完成的功能與文件都差不多補齊了，於是決定來和大家正式分享~\nHypervel 是一個以 Hyperf 框架底層元件爲基礎（類似於 Laravel 和 Symfony 的關係），並將 Laravel 的底層元件全部重構後移植整合進來，解決原本 Laravel 元件在根本設計上沒有考量協程上下文切換會導致的 States Bleeding 問題，並使其能融入 Laravel Hyperf 框架中。基本上現在 Laravel 文件中能看到說明的基礎元件都已經全數完成遷移。\n應該會有人好奇有了 Laravel Octane 爲何還需要 Hypervel 這種看似重複造輪子的新框架？根本原因在於由於 Laravel 在核心設計中是完全沒有考量協程切換問題的，所以即便是 Octane 也只能透過將框架常駐記憶體執行來降低每次 request 的請求成本。但是 Laravel Octane 並未支持任何 Non-Blocking I/O 的特性，若是你的系統沒有 I/O 密集的情境其實 Octane 還是有幫助的，但對於 I/O 需求較重且響應較慢的請求 Octane 會變得一點作用也沒有。\n舉個例子，近幾年隨著 AI 蓬勃發展，越來越多產品在自己的服務中整合 LLM 來提供服務，而每次的 LLM 請求可能都是好幾秒鐘起跳，你會發現你的服務在請求量多時 worker 數量就會瞬間耗盡，而你能做的只有拿出魔法小卡來進行 vertical 或是 horizontal 的 scaling。\n如果你本身是 Laravel 開發者，在你使用 Hypervel 時你應該會覺得很容易上手（當然開發者要對常見作業系統、I/O 與協程等概念有一定程度掌握才不容易踩坑），以下爲 Laravel Hyperf 主要的特色：\n\n提供與 Laravel 框架相同的優雅開發體驗，減少新框架的學習成本\n極高的性能，QPS 在非 I/O 情境下比 Octane 高 10 倍，I/O 密集情境下高出數百倍\n內建的 I/O 相關元件，甚至是 PHP 內建的 I/O 函數都能自動協程化\n物件池與連接池的支援\n能無縫與你既有的 Laravel 專案透過 Cache、Lock 與 Queue 進行雙向溝通\n對於協程支援不僅限於處理使用者的 HTTP 請求，連 Queue 與 Scheduling 都能透過協程達到一個 Process 抵上原本 Laravel 需要開數百個 worker 才能達到的併發能力\n\n歡迎有興趣的大家嘗試，詳細內容可以參照官方網站：hypervel.org\n（文件也是從 Laravel 搬運後修改的，因此會像在查 Laravel 文件一樣親切）\n\n爲了避免混淆以爲他是 Laravel 框架以及註冊商標考量，框架重新命名爲 Hypervel\n"},"為什麼要有例外處理？":{"slug":"為什麼要有例外處理？","filePath":"為什麼要有例外處理？.md","title":"為什麼要有例外處理？","links":[],"tags":[],"content":"假設 PHP 沒有例外機制，那會怎樣呢？\n建立一個函式 sum1()，會回傳兩個參數的總和。參數必須是可以加總的數字，所以 sum1() 的定義中，大部分的程式碼在檢查參數類型，實作功能的程式碼只有 return $x + $y; 而已。\n&lt;?php\n$x = function() {\n  return 1;\n};\n$y = 2;\nprintf(sum1($x, $y));\n \nfunction sum1($x, $y)\n{\n  if( is_string($x) ) {\n    printf(&#039;$x is a string&#039; . PHP_EOL);\n    exit;\n  } else if ( is_string($y) ) {\n    printf(&#039;$y is a string&#039; . PHP_EOL);\n    exit;\n  }\n \n  if( is_callable($x) ) {\n    printf(&#039;$x is a callable object&#039; . PHP_EOL);\n    exit;\n  } else if ( is_callable($y) ) {\n    printf(&#039;$y is a callable object&#039; . PHP_EOL);\n    exit;\n  }\n \n  if( is_object($x) ) {\n    printf(&#039;$x is an object&#039; . PHP_EOL);\n    exit;\n  } else if ( is_object($y) ) {\n    printf(&#039;$y is an object&#039; . PHP_EOL);\n    exit;\n  }\n \n  return $x + $y;\n}\n即使有例外機制，也常常可以看到這樣的程式碼：\n&lt;?php\nsum1($x, $y)\n{\n  if( is_string($x) ) {\n    throw new Exception(&#039;$x is a string&#039;);\n  } else if ( is_string($y) ) {\n    throw new Exception(&#039;$y is a string&#039;);\n  }\n \n  if( is_callable($x) ) {\n    throw new Exception(&#039;$x is a callable object&#039;);\n  } else if ( is_callable($y) ) {\n    throw new Exception(&#039;$y is a callable object&#039;);\n  }\n \n  if( is_object($x) ) {\n    throw new Exception(&#039;$x is an object&#039;);\n  } else if ( is_object($y) ) {\n    throw new Exception(&#039;$y is an object&#039;);\n  }\n \n  return $x + $y;\n}\n這和一開始的範例並無區別，都是產生錯誤訊息，停止執行程式，增加大量的檢查。\n如果有 sum2() 定義如下，只有實作功能的程式碼，不需要檢查參數：\n&lt;?php\nfunction sum2($x, $y)\n{\n  return $x + $y;\n}\n不應該認為使用者會照規矩呼叫程式，應該假設他們會丟各種奇怪的參數進來，必須事先做好防範，但是又要保持函式定義乾淨簡單，所以用例外機制，把錯誤往外丟，在其它地方處理：\n&lt;?php\ntry {\n  $x = function() {\n    return 2;\n  };\n  $y = 3;\n  sum2($x, $y);\n} catch (Throwable $e) {\n  printf(&quot;something wrong happen! at line %s of file %s, and message is %s\\n&quot;,\n      $e-&gt;getLine(),\n      $e-&gt;getFile(),\n      $e-&gt;getMessage()\n    );\n}\nPHP 還有 set_exception_handler() 和 set_error_handler()，不用到處都是 try catch，可以統一在這兩個函式處理所有例外事件。"},"用-Linux-Mint-做為工作環境":{"slug":"用-Linux-Mint-做為工作環境","filePath":"用 Linux Mint 做為工作環境.md","title":"用 Linux Mint 做為工作環境","links":[],"tags":[],"content":"之前用 Windows 10，但是現在又改回用 Linux Mint，因為有一些缺點讓我無法忍受：\n只要停下來幾分鐘不用電腦，就自動開始下載檔案並更新系統，搞得 CPU 和磁碟滿載，而且還一直安裝失敗。即使設定手動安裝 Windows Update，也還是一樣。\nDocker 啟動很慢，即使是啟動 Docker 本身就大約需要 4 分多鐘，還要吃掉 WSL 需要的 2GB 記憶體。\n雖然有用 ClearType，字型還是很醜。我需要在瀏覽器同一頁上顯示繁體中文、簡體中文、日文和韓文，但是 Windows 10 設定用 Noto 字型，只能套用一種字型，結果就是簡體中文仍然是鋸齒狀的字，只能用新同文堂自動轉繁體，自動套用正常的繁體中文字型。\n如果改用 Linux Mint，自然不需要 Windows 10 更新，可以用 100% 全速執行 Docker，不需要擔心 VM 吃掉記憶體，還能像 CSS 那樣設定套用各種字型（參考 用 fontconfig 治理 Linux 中的字型 和 fontconfig調整Linux中文預設字體的優先順序，修正字體模糊、Emoji亂碼的問題 ）\n但是還是有缺點的：\n\n牛津英漢字典只能在 Windows 執行，可以用 KVM 跑 Windows 解決\nLinux 看圖軟體功能普通，不過我並不常看圖，所以沒差\n"},"用-Vim-把事情分得很細":{"slug":"用-Vim-把事情分得很細","filePath":"用 Vim 把事情分得很細.md","title":"用 Vim 把事情分得很細","links":[],"tags":[],"content":"在「內向心理學」這本書(P. 250)提到：\n\n著手工作時將任務分解成小部份。對性格內向者來說，這是最有益的方式。它有助於你減輕焦慮、頭腦不清和無助的感覺。\n\n「工作大解放: 這樣做事反而更成功」提到把大計劃分成小計劃，會改變你的人生\n\n創造速贏：別耗太久，沒有人喜歡追逐看不到的終點線。養成一路上達成許多小勝利的習慣，如此便能保有氣勢、增強動機。\n…解決的辦法就是把大事化分成數件小事。要辦的事情規模愈小，就愈容易預測\n優先的事情總是一大堆。這種做法其實不是排序。你應該做的是視覺上的優先順序。把最重要的事情列在最上面，當你做完一件事，在清單上的下一件事就是下一個最重要的事\n\n「為什麼他接的案子比我多？」第35章如何吃下一頭大象則是說：\n\n細分成「口服」份量…我們把任務仔細的分解\n…工作細分的大小，應該跟案子大小成反比：案子愈大，分的愈細\n\n所以把事情分解成更小的事項，可以保持速贏、容易預測時間、減輕無助與焦慮，好處多多。一直以來我參考 XDite 的建議使用 Redmine 這個專案管理軟體分解工作事項。參考淺談軟體專案管理，如何挑選工具與方法\n\n我們怎用 Redmine ? 會用 Redmine 是因為試到一個功能其他專案管理軟體「都沒有」。就是「無限的巢狀票」… 範例圖片\n\n但是 Redmine 有一些缺點，讓我受不了：\n\n不好安裝和備份: 用 Docker 安裝方便很多，但是用 Dropbox 備份 SQLite 資料庫，我老是覺得檔案太大\n字太小：不熟 Redmine 的 CSS 設定，而且每次更新不就都要改 CSS？\n不方便調整 issue 順序：常常工作到一半發現需要調整 issue 順序，到上一層或下一層，調到其他 issue 成為 sub-issue 等\n\n改用 Vim 就方便許多：\n\n就只是一個文字檔，備份很方便\nVim 字型大小遵照終端機設定，一般用滑鼠按一按即可找到。更新 Vim，設定也不會變\n用 Vim 折疊功能，打開來就是 issue 內容，折起來又能看整份大綱\n設定向右二個空格為一層，和 Redmine issue 一樣都是向右縮排視為子票\n能用 Vim 本身的功能快速操作：\n\n用 :set foldlevel=2 只打開到第二層\n&gt;&gt; 移動到下一層，&lt;&lt; 移動到上一層\n用 Visual 模式選好範圍，用 d 和 p 剪下貼上即可移動整個 issue\n一點小小設定就能用 Ctrl + 向上/向下 把整行上下移動，比一般 todo list 軟體用滑鼠更準確、方便\n\n\n\n不過也是有缺點的：\n\n不能附加檔案，例如圖片\n需要熟悉 Vim\n\n在 home 目錄的檔案 .vimrc 加入以下設定，一個雙引號開頭是註解，可省略\n&quot; 依照縮排折疊\nset foldmethod=indent\n&quot; 設定一層是向右縮排幾個空格\nset shiftwidth=2\n&quot; 折疊到剩下幾層。這裡是打開檔案時不折疊，因為一般不會向右縮排到十層吧？\nset foldlevel=10\n&quot; 大於多少行才要折疊，預設是 1\nset foldminlines=0\n&quot; 啟用折疊\nset foldenable\n \n&quot; Ctrl + J / K 向下/向上一行移動\nnnoremap &lt;C-j&gt; :move +1&lt;CR&gt;\nnnoremap &lt;C-k&gt; :move -2&lt;CR&gt;\nnnoremap 表示在 Normal 模式下執行，&lt;C-j&gt; 表示 Ctrl + J，Ex 指令 :move +1 是把目前游標的那一行向下一行移動， :move -2 則是向上一行移動，&lt;CR&gt; 是 Enter。\n&lt;C-j&gt; 的 C 可以改成 S (Shift)、A (Alt)、或 M (Meta)，方向鍵是 UP (向上) 和 DOWN (向下)，所以 Ctrl + 向上 是 &lt;C-UP&gt;\n以下是 Vim 的折疊相關指令\n\nzo：打開游標所在的那一層折疊\nzc：關閉游標所在的那一層折疊\nza：切換游標所在的那一層折疊\nzA：切換游標所在的每一層折疊\nzO：打開游標所在的每一層折疊\nzC：關閉游標所在的每一層折疊\nzr：foldlevel + 1\nzm：foldlevel - 1\nzR：打開每一層折疊\nzM：等於 set foldlevel=0\nzi：切換啟用折疊功能\nzx：更新折疊。取消手動打開或關閉的折疊，重新套用 foldlevel\nzX：取消手動打開或關閉的折疊，重新套用 foldlevel\n[z：到目前開啟的折疊中，和游標同一層的第一個摺疊\n]z：到目前開啟的折疊中，和游標同一層的最後一個摺疊\nzj：向下移動。到達下一層摺疊的第一個。關閉的摺疊也被計入\nzk：向上移動。到達下一層摺疊的最後一個。關閉的摺疊也被計入\n"},"解-UVa-線上解題系統的題目":{"slug":"解-UVa-線上解題系統的題目","filePath":"解 UVa 線上解題系統的題目.md","title":"解 UVa 線上解題系統的題目","links":[],"tags":[],"content":"依照之前的經驗，寫程式分成以下的步驟：\n\n定義需求\n需求轉換成執行步驟\n步驟翻譯成程式碼\n電腦執行程式碼\n\n我覺得第二點最困難，業界還給這種轉換能力取名 Computational Thinking，不過我怎麼看都覺得類似數學思考的方法。我目前最缺少的就是這種思考解題能力，所以解 UVa 題目1，把解題過程和程式碼都寫成文章，以為憑證。\n第三點所需的程式語言和框架語法並不難學，前幾天複習 PHP 和 Laravel 官方文件，其實大多還記得。UVa 題目最後的程式碼用 Python 語法，因為 PHP 適合寫網站，不是終端機程式2，而且最近學了一點 Python，正好寫題目來練習。\nQ100 3n + 1\n已知\nn = 22，產生數列 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1。cycle length 為 16\ni, j ⇒ 例如 1, 5\n所求：輸入 i 和 j，例如 1 和 5，求 1 到 5 之間的最大的 cycle length\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nn數列cycle length11122, 1233, 10, 5, 16, 8, 4, 2, 1844, 2, 1355, 16, 8, 4, 2, 16\n最大的 cycle length 為 8\n輸入 1 5，輸出 1 5 8\nMURMUR：輸出 1 10 或 10 1，輸出 1 10 20 或 10 1 20\n所以有可能 i &gt; j 或 i &lt; j\nAHA: 輸入值為 x, y，然後 i = 最小值(x, y)，j = 最大值(x, y)，這樣保證 i &lt; 或等於 j\ns = input().split()\nx, y = int(s[0]), int(s[1])\ni, j = min(x, y), max(x, y)\n \nlength = 1\nmax_length = 1\nfor n in range(i, j):\n    # 求 n 的 cycle length\n    # 找出最大的 cycle length\ndef cycle_length(n):\n    cycle_length = 1\n    if n == 1:\n        return cycle_length\n    elif n 是奇數:\n        n = 3 * n + 1\n    else:\n        n = n / 2\n \n    cycle_length += 1\nwhile 終止的條件是 n == 1，所以\ndef cycle_length(n):\n    cycle_length = 1\n    while n != 1:\n        if (n % 2) == 1:\n            n = 3 * n + 1\n        else:\n            n = n / 2\n \n        cycle_length += 1\n \n    return cycle_length\n最後的程式碼\ndef cycle_length(n):\n    cycle_length = 1\n    while n != 1:\n        if (n % 2) == 1:\n            n = 3 * n + 1\n        else:\n            n = n / 2\n \n        cycle_length += 1\n \n    return cycle_length\n \n \nwhile True:\n    s = input().split()\n    x, y = int(s[0]), int(s[1])\n    i, j = min(x, y), max(x, y)\n \n    max_cycle_length = 0\n    for n in range(i, j + 1):\n        length = cycle_length(n)\n        max_cycle_length = max(length, max_cycle_length)\n \n    print(i, j, max_cycle_length)\nQ272 TeX Quotes\n&quot;To be or not to be,&quot; quoth the Bard, &quot;that\nis the question&quot;.\nThe programming contestant replied: &quot;I must disagree.\nTo `C&#039; or not to `C&#039;, that is The Question!&quot;\n\n輸入若干列文字(所以用 input() 會有問題)，…以 end-of-file 做結束(所以會讀取檔案)…\n把每一個字元抓出來\nif 字元是雙引號\n    if 第一個雙引號\n        把雙引號換成兩個 ` 字元\n    else\n        把雙引號換成 2 個單引號\nelse\n    字元存到字串的尾端 (result )\n\nprint(result)\n\nSTUCK：怎麼知道是第一個雙引號，還是第二個？\nAHA：用一個變數紀錄 first_double_quote = True\nif first_double_quote\n    # 把雙引號換成 ` 字元\n    first_double_quote = False\nelse:\n    # 把雙引號換成兩個單引號\n    first_double_quote = True\n最後結果\n# 讀取檔案為字串\nf = open(&quot;Q272_input.txt&quot;, &quot;rt&quot;)\nfirst_double_quote = True\nresult = &quot;&quot;\n \nfor line in f:\n    # 把每一個字元抓出來\n    for s in line:\n        # if 字元是雙引號\n        if s == &#039;&quot;&#039;:\n            # 第一個雙引號\n            if first_double_quote:\n                # 把雙引號換成兩個 `` 字元\n                result += &quot;``&quot;\n                first_double_quote = False\n            # 第二個雙引號\n            else:\n                # 把雙引號換成兩個單引號\n                result += &quot;&#039;&#039;&quot;\n                first_double_quote = True\n        # 不是雙引號\n        else:\n            # 字元存到字串尾端\n            result += s\n \nf.close()\nprint(result)\nQ272_input.txt\n&quot;To be or not to be,&quot; quoth the Bard, &quot;that\nis the question&quot;.\nThe programming contestant replied: &quot;I must disagree.\nTo `C&#039; or not to `C&#039;, that is The Question!&quot;\n\nQ458 The Decoder\na — +2 ⇒ c — -2 ⇒ a\np -⇒ r -⇒ p\np -⇒ r -⇒ p\nl -⇒ n -⇒ l\nK 是多少？\n1 --- -K ⇒ *\nJ -⇒ C\nK -⇒ D\nJ -⇒ C\nABCDEFGHIJK\n所以 K = 7\nwhile True\n    輸入一列字串\n    抓取每一個字元\n    字元減掉 K(=7)\n    把解密後的字元存到字串\n    print 字串\n\nwhile True:\n    password = input()\n    result = &quot;&quot;\n    for c in password:\nSTUCK：字元是字串，不能直接減掉 7\nAHA 字元 -⇒ ASCII Code -⇒ 減掉 7 -⇒ 字元\nA ---- ord(&#039;A&#039;) ⇒ 65 -⇒ 58 ---- chr(58) ⇒ :\nascii_code = ord(c) - 7\ndecoded_c = chr(ascii_code)\nresult += decoded_c\n \nprint(result)\n最後結果\nK = 7\nwhile True:\n    # 輸入一列字串\n    password = input()\n    # 抓取每個字元\n    decoded_password = &#039;&#039;\n    for c in password:\n        # 字元減掉 K(= 7)\n        #   字元 --&gt; ASCII Code --&gt; 減掉 K --&gt; 字元\n        ascii_code = ord(c)\n        decoded_ascii_code = ascii_code - K\n        decoded_char = chr(decoded_ascii_code)\n        # 把解密後的字元存到字串\n        decoded_password += decoded_char\n    # print 字串\n    print(decoded_password)\n測試資料\n# 輸入\n1JKJ&#039;pz&#039;{ol&#039;{yhklthyr&#039;vm&#039;{ol&#039;Jvu{yvs&#039;Kh{h&#039;Jvywvyh{pvu5\n# 輸出\n*CDC is the trademark of the Control Data Corporation.\n\nQ476 Points in Figures: Rectangles\nr 8.5 17.0 25.5 -8.5\n類別 左上x 左上y 右下x 右下y (x1 y2 x2 y1)\n所以 x 在 8.5 ~ 25.5, y 在 -8.5 ~ 17.0\n\n*\n2.0 2.0\nx   y\n\n點的 x 要在矩形的 x 範圍內且 y 在矩形的 y 的範圍內，則點在此矩形內。剛好落在邊上的點不視為落在該矩形內，所以 矩形的 x1 &lt; 點的 x &lt; 矩形的 x2，矩形的 y1 &lt; 點的 y &lt; 矩形的 y2，不含x 等於 x1 或 x2 的邊界情況\nx = 2.0 不在 8.5 ~ 25.5 內，所以第一個點不在第一個矩形內\n\n輸入矩形座標\n輸入點座標\n檢查點是否在矩形內\n4. 抓出一個點\n5. 抓出一個矩形\n6. if 點的x在矩形的x1 ~ x2 且 y 在矩形的y1 ~ y2，則輸出 Point i is contained in figure j\n7. 如果所有矩形檢查過都沒有，則輸出 Point i is not contained in any figure\n\n輸入矩形座標\n讀取 terminal 輸入 ⇒ input() 一次讀取一行\nif 只有一個一個字元且為 `*`\n    矩形輸入結束\n\n所以\nwhile True:\n    s = input()\n    if len(s) == 1 and s == &quot;*&quot;:\n        break\n    else:\n抓取矩形座標，放到 dict ，再放到 list\nrectangles = []\nr = s.split() # --&gt; [&#039;r&#039;, &#039;8.5&#039;, &#039;17.0&#039;, &#039;25.5&#039;, &#039;-8.5&#039;]\nrectangle = {\n        &quot;x1&quot;: float(r[1]),\n        &quot;y2&quot;: float(r[2]),\n        &quot;x2&quot;: float(r[3]),\n        &quot;y1&quot;: float(r[4]),\n    }\n    rectangles.append(rectangle)\n輸入點座標，和輸入矩形座標差不多\nwhile True:\n    s = input()\n    p = s.split() # --&gt; [&#039;2.0&#039;, &#039;2.0&#039;]\n    if len(p) == 2 and p[0] == &quot;9999.9&quot; and p[1] == &quot;9999.9&quot;:\n        break\n    else:\n        points = []\n        point = { &quot;x&quot;: float(p[0]), &quot;y&quot;: float(p[1]) }\n        points.append(point)\n檢查點是否在矩形內\ni = 0, j = 0\nfor point in points:\n    i = i + 1\n    is_point_in_rectangles = False\n    for rectangle in recangles:\n        j = j + 1\n        if rectangle[&#039;x1&#039;] &lt; point[&#039;x&#039;] &lt; rectangle[&#039;x2&#039;]:\n            print(&#039;Point &#039; + i + &#039; is contained in figure &#039; + j)\n            is_point_in_rectangle = True\n \n    if not is_point_in_rectangle:\n        print(&#039;Point &#039; + i + &#039; is not contained in any figure&#039;)\n最後結果：有修改小地方\n# 新增矩形\nrectangles = []\nwhile True:\n    s = input()\n    if len(s) == 1 and s == &quot;*&quot;:\n        break\n \n    r = s.split()\n    rectangle = {\n        &quot;x1&quot;: float(r[1]),\n        &quot;y2&quot;: float(r[2]),\n        &quot;x2&quot;: float(r[3]),\n        &quot;y1&quot;: float(r[4]),\n    }\n    rectangles.append(rectangle)\n \n# 新增點\npoints = []\nwhile True:\n    s = input()\n    p = s.split()\n    if len(p) == 2 and p[0] == &quot;9999.9&quot; and p[1] == &quot;9999.9&quot;:\n        break\n \n    point = { &quot;x&quot;: float(p[0]), &quot;y&quot;: float(p[1]) }\n    points.append(point)\n \n# 判斷點是否在矩形內\nfor i, p in enumerate(points):\n    contained_in_figure = False\n    for j, r in enumerate(rectangles):\n        if r[&quot;x1&quot;] &lt; p[&quot;x&quot;] &lt; r[&quot;x2&quot;] and r[&quot;y1&quot;] &lt; p[&quot;y&quot;] &lt; r[&quot;y2&quot;]:\n            print(&quot;Point {} is contained in figure {}&quot;.format(i + 1, j + 1))\n            contained_in_figure = True\n \n    if not contained_in_figure:\n        print(&quot;Point {0} is not contained in any figure&quot;.format(i + 1))\nQ477 Points in Figures: Rectangles and Circles\n輸入有兩種形狀：矩形和圓形\nr 8.5 17.0 25.5 -8.5 ⇒ 矩形\nc 20.2 7.3 5.8 ⇒ 圓形\n20.2 7.3 是圓心座標， 5.8 是圓半徑\nSTUCK：怎麼知道點是否在圓內？\nAHA：(畫圖：一個圓和幾個點) 點到圓心的距離小於圓半徑\nSTUCK：點到圓心的距離怎麼計算？\nAHA：如果點 p = (3, 4), 圓心 c = (10, 20)，距離 = 開根號( (3 - 10)的平方 + (4 - 20)的平方 )\n附註：上面這一行在紙上實際上是數學公式，只是不方便輸入到電腦上，所以這樣寫\n輸入形狀\nif 形狀是矩形\n    抓 4 個座標值\nelse if 形狀是圓形\n    抓圓心座標和半徑\n\n輸入點：同 Q476\n檢查是否在圓形內\n抓一個點\n    抓一個圖形\n        if 圖形是矩形\n            矩形 x1 &lt; 點 x &lt; 矩形 x2, 矩形 y1 &lt; 點 y &lt; 矩形 y2\n        else if 圖形是圓形\n            開根號( (點x - 圓心x)的平方 + (點y - 圓心y)的平方 ) &lt; 圓半徑\n\n開根號 math.sqrt()，平方 math.pow(點x - 圓心x, 2)\nimport math\n \n# 新增矩形\nshapes = []\nwhile True:\n    s = input()\n    if s == &quot;*&quot;:\n        break\n \n    r = s.split()\n    # 輸入矩形\n    if r[0] == &quot;r&quot;:\n        shape = {\n            &quot;type&quot;: &quot;rectangle&quot;,\n            &quot;x1&quot;: float(r[1]),\n            &quot;y2&quot;: float(r[2]),\n            &quot;x2&quot;: float(r[3]),\n            &quot;y1&quot;: float(r[4]),\n        }\n    # 輸入圓形\n    elif r[0] == &quot;c&quot;:\n        shape = {\n            &quot;type&quot;: &quot;circle&quot;,\n            &quot;x&quot;: float(r[1]),\n            &quot;y&quot;: float(r[2]),\n            &quot;r&quot;: float(r[3])\n        }\n    shapes.append(shape)\n \n# 新增點\npoints = []\nwhile True:\n    s = input()\n    p = s.split()\n    if p[0] == &quot;9999.9&quot; and p[1] == &quot;9999.9&quot;:\n        break\n \n    point = {&quot;x&quot;: float(p[0]), &quot;y&quot;: float(p[1])}\n    points.append(point)\n \n# 判斷點是否在矩形內\ncontained_in_figure = False\nfor i, point in enumerate(points):\n    for j, shape in enumerate(shapes):\n        if (\n            shape[&quot;type&quot;] == &quot;rectangle&quot;\n            and shape[&quot;x1&quot;] &lt; point[&quot;x&quot;] &lt; shape[&quot;x2&quot;]\n            and shape[&quot;y1&quot;] &lt; point[&quot;y&quot;] &lt; shape[&quot;y2&quot;]\n        ):\n            print(&quot;Point {} is contained in figure {}&quot;.format(i + 1, j + 1))\n            contained_in_figure = True\n        elif (\n            shape[&quot;type&quot;] == &quot;circle&quot;\n            and math.sqrt(math.pow(shape[&quot;x&quot;] - point[&quot;x&quot;], 2) + math.pow(shape[&quot;y&quot;] - point[&quot;y&quot;], 2))\n            &lt; shape[&quot;r&quot;]\n        ):\n            print(&quot;Point {} is contained in figure {}&quot;.format(i + 1, j + 1))\n            contained_in_figure = True\n \n    if not contained_in_figure:\n        print(&quot;Point {0} is not contained in any figure&quot;.format(i + 1))\n \n    contained_in_figure = False\nQ488 Triangle Wave\n2 ⇒ 有 2 組測試資料\n3 ⇒ A 振幅 (A ⇐ 9)\n2 ⇒ F 頻率\n5\n3\nSTUCK: 什麼是振幅？\nAHA: 波上下起伏的大小\nSTUCK: 什麼是頻率？\nAHA: 例如每秒幾次(幾個波)。相反的，週期是指做一次(一個波)要多久\nF = 2 ⇒ 輸出 2 個波，每個波振幅的水平高度為 A ⇒ A = 3 ⇒ 波最大為 333\nSTUCK: 要怎麼輸入資料？\nn = int(input())\ngroups = []\nfor i in range(0, n):\n    A = int(input())\n    F = int(input())\n    group = { &#039;A&#039;: A, &#039;F&#039;: F}\n    groups.append(group) # for 抓出一個 group[&#039;A&#039;] 為 A 的值(振幅)\nSTUCK: 如果 A = 3, 要怎麼產生波如下？\n1\n22\n333\n22\n1\n\n\n先產生 333\n\nfor i in range(0, 3):\n    print(3, end=&quot;&quot;) # 不換行\n\n產生\n\n1\n22\n333\n\nfor A in range(1, 4):\n    for i in range(0, A):\n        print(A, end=&quot;&quot;)\n    print()\n\n產生\n\n22\n1\n\n愈來愈少(2, 1)\nfor A in range(2, 0, -1):\n    for i in range(0, A):\n        print(A, end=&quot;&quot;)\n    print()\n產生一個波：2) + 3)\nA = 3\n# 2)\nfor i in range(1, A + 1):\n    for j in range(0, i):\n        print(i, end=&quot;&quot;)\n    print()\n# 3)\nfor i in range(A - 1, 0, -1):\n    for j in range(0, i):\n        print(i, end=&quot;&quot;)\n    print()\n產生多個波就包上一個 for 迴圈，外面再包上一個 for 表示有多筆測試資料\nfor group in groups:\n    # 共產生 F 個波\n    for f in range(0, F):\n        # 帶入上面的產生一個波\n    print()\n最後組裝起來，調整一下\n# 輸入有 n 組測試資料\nn = int(input())\nprint()\n \n# 開始輸入測試資料\ngroups = []\nfor i in range(0, n):\n    A = int(input())\n    F = int(input())\n    group = {&quot;A&quot;: A, &quot;F&quot;: F}\n    groups.append(group)\n    print()\n \nfor group in groups:\n    A = group[&#039;A&#039;]\n    F = group[&#039;F&#039;]\n    # 產生幾個波\n    for f in range(0, F):\n \n        # 產生一個波\n        # 如果 A = 3\n        # 1\n        # 22\n        # 333\n        for i in range(1, A + 1):\n            for j in range(0, i):\n                print( i , end=&quot;&quot; )\n            print()\n        # 22\n        # 1\n        for i in range(A - 1, 0, -1):\n            for j in range(0, i):\n                print(i, end=&quot;&quot;)\n            print()\n        # 產生一個波後，換行\n        print()\nQ494 Kindergarten Counting Game\n亂七八糟的開始\n\n一開始急著解答，所以寫的亂七八糟，沒什麼用。寫出來是為了呈現真實的情況：寫程式的過程並不是都那麼順遂的\n\nMeep Meep! 2\nI tot I taw a putty tat. 7\nI did! I did! I did taw a putty tat. 10\nShssssssssssh … I am hunting wabbits. Heh Heh Heh Heh … 9\nMeep\nM: 開始連續的英文字母\np: 停止連續的英文字母\n\n把一行字串的每一個字串抓出來\nM 是在 A ~ Z 或 a ~ z 嗎？(正規表示法？)\nif yes, 連續英文字母 = True\ne if yes, 連續英文字母 = True\ne if yes, 連續英文字母 = True\np if yes, 連續英文字母 = True\n(空白) else 連續英文字母 = False\n從 yes ⇒ No, word 數 +1\n\n一開始，連續英文字母 = False\n把一行字串的每一個字元抓出來\nif 字元在 A ~ Z 或 a ~ z 之間\n連續英文字母 = True\nline_str = input()\nword_start == False\nfor s in line_str\n    if s 在 A ~ z, a ~ z 之間\n        word_start = True # 開始一個新的字(word)\nAHA: 所以有四種情況\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n原來的 word_start = True原來的 word_start = Falses A ~ Z, a ~ z Trues A ~ Z, a ~ z False\n有耐心的特殊化\n\n從這裡開始，有耐心的特殊化，就好多了\n\n一開始, word 數 = 0\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n字元word_start字元是英文字母word 數M✓⇐ ✓0e✓⇐ ✓0e✓⇐ ✓0(1)p✓⇐ ✓0(空白)x⇐ x1(2)M✓⇐ ✓1(3)\nif word_start == True and not (s 是英文字母)\n    word_count += 1\n    word_start = False\n \nif word_start == False and s 是英文字母\n    word_start = True\n\nword_start = False\nword 數 = 0\nfor s in 一行字串\n    if word_start:\n        if s 是英文字母\n            # (1)\n        else:\n            # (2)\n            word 數 += 1\n            word_start = False\n    else:\n        if s 是英文字母:\n            # (3)\n            word_start = True\n        else:\n            # (4) &lt;-- 字元是 ! 或 .\n \nprint(word_count)\n把上面的 code 包在 while True 內，for 迴圈跑完, word_start = False, word_count = 0\nSTUCK: 如果結尾沒有標點符號，會少算一個 word\n例如 This is a test\n顯示為 3，正確值 4\n改成 not s 是英文字母，或已到字串結尾\nfor i, s in 一行字串\n    (i + 1) == len(一行字串)\n最後的結果\nimport re\n \nwhile True:\n    word_start = False\n    word_count = 0\n \n    line_of_string = input()\n    for i, c in enumerate(line_of_string):\n        match = re.match(r&#039;[a-zA-Z]&#039;, c)\n        # match is None: 字元不是英文字母\n        # i + 1 == len(line_of_string): 單純是該行結束了\n        if word_start and (match is None or (i + 1) == len(line_of_string)):\n            word_count += 1\n            word_start = False\n        if not word_start and not( match is None ):\n            word_start = True\n \n    print(word_count)\n \nFootnotes\n\n\nUVa線上解題系統 ↩\n\n\n我知道有 STDIN 這個東西，只是… ↩\n\n\n"},"解決-VTE-為基礎的終端機程式游標問題":{"slug":"解決-VTE-為基礎的終端機程式游標問題","filePath":"解決 VTE 為基礎的終端機程式游標問題.md","title":"解決 VTE 為基礎的終端機程式游標問題","links":[],"tags":[],"content":"這幾天改用 Windows 10，用 VirtualBox 建立 Alpine Linux 虛擬環境，用來跑 docker。其中用 ssh 連到 Linux，再用 Vim 編輯檔案，結果發現游標不是我習慣的那樣。正常情況下，在 normal 模式，游標會選取字元並反白，按 i 會進入 insert 模式，字元不再選取，| 游標會在左邊，然後可以開始輸入，如果按 a 則 | 游標會在右邊。但是現在卻變成不管是哪個模式，游標都一樣，例如全部都是 |，即使是 normal 模式。Neovim 則無此問題。\nGoogle 後發現 Vim 用以下的設定就能恢復正常，其中最後三行的 set 讓游標切換沒有大約一秒的延遲。\nlet &amp;t_SI = &quot;\\&lt;Esc&gt;[6 q&quot; &quot; I beam cursor for insert mode\nlet &amp;t_SR = &quot;\\&lt;Esc&gt;[4 q&quot; &quot; underline cursor for replace mode\nlet &amp;t_EI = &quot;\\&lt;Esc&gt;[2 q&quot; &quot; block cursor for normal mode\nset ttimeout\nset ttimeoutlen=1\nset ttyfast\nVTE 是 Virtual Terminal Emulator（虛擬終端模擬器）的縮寫，為 Gnome 的一部分，它提供 API 以建立各種終端機程式，功能強大。會有游標問題，似乎是因為 VTE 可以自訂游標，Vim 如果沒有特別設定，便會依照終端機的設定全部模式都用相同的游標\n資料參考\n\nHow to change the cursor between Normal and Insert modes in Vim?\nhelp I’ve tried to change my cursor shape for hours\nChange cursor shape in different modes\n探索GNOME的VTE库：一个强大的终端模拟器引擎\n"},"資料庫正規化，以魔法學校課程為例":{"slug":"資料庫正規化，以魔法學校課程為例","filePath":"資料庫正規化，以魔法學校課程為例.md","title":"資料庫正規化，以魔法學校課程為例","links":[],"tags":[],"content":"魔法學校選課資料\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n姓名課程必選修及格教師妙麗飛行學, 魔藥學, 符咒學必選, 必選, 必選及格, 及格, 及格胡奇, 石內卜, 孚立維湯姆黑魔法防禦術, 古代神秘文字研究,  占卜學必選, 選修, 選修及格, 不及格, 不及格鄧不利多, 戴華德, 勒梅\n1NF：去除重複\n第一正規化 (1NF) 是去除重複，所以：\n\n每個欄位只有一個值\n沒有任何兩筆以上資料是重複的\n\n一格內不能重複放多筆資料，例如欄位課程放了不只一筆資料，如果要過濾出有科目不及格的學生及其科目，很難下 SQL 語法，所以一格只能放一筆資料。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n姓名課程必選修及格教授妙麗飛行學必修及格胡奇妙麗魔藥學必修及格石內卜妙麗符咒學必修及格孚立維湯姆黑魔法防禦術必選及格鄧不利多湯姆古代神秘文字研究選修不及格戴華德湯姆占卜學選修不及格勒梅\n這樣要過濾出有科目不及格的學生及其科目，可以用以下的 SQL\nSELECT 姓名, 課程, 必選修, 教授\nFROM 魔法學校選課資料\nWHERE 及格 = &#039;不及格&#039;\n如果魔法學校有相同姓名的學生在同一年級，例如有 2 個哈利，則會出現重複的資料，所以加上絕不會重複的編號，名爲主鍵，就能用 SQL 語法找出要的是哪一列資料\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n編號姓名課程必選修及格教授1哈利飛行學必修及格胡奇2哈利魔藥學必修及格石內卜3哈利符咒學必修及格孚立維4哈利飛行學必修及格胡奇5哈利魔藥學必修及格石內卜6哈利符咒學必修及格孚立維\n選擇 6 號資料\nSELECT *\nFROM 魔法學校選課資料\nWHERE 編號 = 6\n2NF：去除部分相依\n第二正規化(2NF)：\n\n符合第一正規化\n所有非主鍵欄位都完全相依於主鍵，沒有部分相依\n\n完全相依？部分相依？\n\n相依性：某個欄位的值是跟著另一欄位的值改變，例如必選修與否是跟著課程決定。\n完全相依：非主鍵欄位相依而且只相依於主鍵，例如姓名要相依於編號\n部分相依：非主鍵欄位相依之間相依，而不相依於主鍵。例如必選修相依於課程，而不是主鍵編號\n\n如果開學前要規劃新的課程，但是學生尚未入學，所以只是要新增課程。上述選課資料表沒有符合 2NF，要單獨新增課程實在很困難，會留下許多不必要的空格。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n編號姓名課程必選修及格教授飛行學必修胡奇\n去除部分相依的方法是把部分相依欄位依照相依性另成一張表：\n\n課程、必選修和教授獨立出課程資料表\n編號和姓名獨立出學生資料表\n及格相依於學生編號和課程，所以獨立出成績資料表\n\n學生\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n編號姓名1哈利2榮恩3妙麗4湯姆\n課程\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n編號名稱必選修教授1飛行學必修胡奇2魔藥學必修石內卜3符咒學必修孚立維\n成績\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n學生編號課程編號及格11及格12及格21及格\n3NF：去除遞移相依\n第三正規化(3NF)：\n\n符合第二正規化\n所有非主鍵欄位沒有遞移相依\n\n遞移相依：非主鍵欄位之間有相依性。\n我覺得遞移相依和部分相依根本是一樣的，所以 2NF 和 3NF 是一樣的？\n如果在課程資料表新增教授的年齡和性別，則這兩個欄位和教授姓名完全相依，但是和課程編號部分相依，所以應該把教授獨立出一個資料表\n教授\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n編號姓名年齡性別1鄧不利多250男2石內卜50男3胡奇55女\nB-C NF：主鍵不相依於非主鍵\nBoyce-Codd 正規化(B-C NF)：\n\n符合第三正規化\n主鍵的各個欄位不相依於非主鍵欄位\n\n所以主鍵如果只有一個欄位，則只要符合第三正規化，就符合 B-C 正規化。只有複合主鍵需要考慮第二個條件。\n成績資料表中，欄位學生編號沒有相依於及格，課程編號也沒有相依於及格，所以符合 B-C 正規化\n成績\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n學生編號課程編號及格11及格12及格21及格\nER-Model\n首先描述需求，從中找出名詞，決定彼此之間的關係。\n今天哈利來到霍格華茲，認識了同學榮恩和妙麗，他們一起上一年級，基本上都是必修課，有飛行學、魔藥學和符咒學，教授分別是胡奇、石內卜和孚立維。他們三個人中妙麗最用功，成績最好，榮恩則是常常唸錯咒語，符咒學看來很難及格，哈利一下子就能騎著光輪2000到處飛來飛去，胡奇教授對他另眼相看。\n需求描述中的名詞有同學、必修課、年級、教授和成績，接著決定彼此間的關係：\n\n一個學生可以修多個課程，一個課程可以有多個學生修習，多對多關係需要拆分出樞紐資料表。欄位學生和課程決定出這個學生在這門課的成績，所以獨立出成績資料表\n一個教授可以教多個課程，一個課程只能有一個教授，所以是一對多關係\n\n"},"這週看了什麼書":{"slug":"這週看了什麼書","filePath":"這週看了什麼書.md","title":"這週看了什麼書","links":[],"tags":[],"content":"「假面飯店」\n「父母效能訓練」\n書上的技巧其實是人際關係的基本原則，適用於任何關係，父母與孩子、上司與下屬、老師與學生、朋友與朋友、夫妻之間，所以我才看這本書\n「用五個為什麼，找出問題發生的真因」\n「5 位臺大生教你這樣做筆記」\n最近開始看很多書，有些需要做筆記，剛好在圖書館看到這本書，就借來看看。看到書上的筆記範例，覺得他們能上台大真是不容易啊，也是很辛苦的。把課本內容用表格做比較、用樹狀結構條列、用年代數線歸類主要發生的事件、手繪地圖並標示，做完這些，能幫助自己理解，也方便快速複習。在數學、物理、化學，特別提到「要用自己的話好好想清楚」，還有在課本上「自問自答」，因為「如果你懂得自問自答，那就是真的懂了！觀念真的貫通了！」例如理想氣體常數 R 值之影響因素：原子量標，直接在課本上寫下 ex: if C = 12.000 =&gt; n 變大，R 變小，在物理科甚至還有一整段特別說明\n\n當你會解釋，你就會了\n要知道自己這個單元究竟學得如何，最好的辦法就是當有人來問你問題時，試著解釋得讓別人完全明暸，這其實並不容易。理解跟解釋可是大不相同，有時候可能會解釋到煩了一一怎麼連這個都不會。不要怪別人，如果自己是透徹了解，那更應該解釋得精彩又清楚，所以下次有人問你問題時，可不要覺得麻煩，這可是千載難逢，檢視自己學習成效的大好機會\n\n類似的方法也出現在「超速學習」這本書上。原來那些建中、北一女學生也是用同樣的方式學習才考上臺大"}}